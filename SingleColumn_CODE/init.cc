#include "definitionsInternal.h"
#include <iostream>
#include <random>
#include <cstdint>

struct MergedNeuronInitGroup0
 {
    float* inSynInSyn10;
    float* denDelayInSyn6;
    unsigned int* denDelayPtrInSyn6;
    float* inSynInSyn7;
    float* denDelayInSyn7;
    unsigned int* denDelayPtrInSyn7;
    float* inSynInSyn8;
    float* denDelayInSyn8;
    unsigned int* denDelayPtrInSyn8;
    float* inSynInSyn9;
    float* denDelayInSyn9;
    unsigned int* denDelayPtrInSyn9;
    float* inSynInSyn6;
    float* denDelayInSyn10;
    unsigned int* denDelayPtrInSyn10;
    float* inSynInSyn11;
    float* denDelayInSyn11;
    unsigned int* denDelayPtrInSyn11;
    float* inSynInSyn12;
    float* denDelayInSyn12;
    unsigned int* denDelayPtrInSyn12;
    float* inSynInSyn13;
    float* denDelayInSyn13;
    unsigned int* denDelayPtrInSyn13;
    float* denDelayInSyn2;
    unsigned int* spkCnt;
    unsigned int* spk;
    scalar* V;
    scalar* RefracTime;
    float* inSynInSyn0;
    float* denDelayInSyn0;
    unsigned int* denDelayPtrInSyn0;
    float* inSynInSyn1;
    float* denDelayInSyn1;
    unsigned int* denDelayPtrInSyn1;
    float* inSynInSyn2;
    unsigned int* denDelayPtrInSyn2;
    float* inSynInSyn3;
    float* denDelayInSyn3;
    unsigned int* denDelayPtrInSyn3;
    float* inSynInSyn4;
    float* denDelayInSyn4;
    unsigned int* denDelayPtrInSyn4;
    float* inSynInSyn5;
    float* denDelayInSyn5;
    unsigned int* denDelayPtrInSyn5;
    unsigned int numNeurons;
    
}
;
struct MergedNeuronInitGroup1
 {
    float* inSynInSyn3;
    unsigned int* denDelayPtrInSyn7;
    float* denDelayInSyn7;
    float* inSynInSyn7;
    unsigned int* denDelayPtrInSyn6;
    float* denDelayInSyn6;
    float* inSynInSyn6;
    unsigned int* denDelayPtrInSyn5;
    float* denDelayInSyn5;
    float* inSynInSyn5;
    unsigned int* denDelayPtrInSyn4;
    float* denDelayInSyn4;
    float* inSynInSyn4;
    unsigned int* denDelayPtrInSyn3;
    float* denDelayInSyn3;
    unsigned int* denDelayPtrInSyn2;
    float* denDelayInSyn2;
    float* inSynInSyn2;
    unsigned int* denDelayPtrInSyn1;
    float* denDelayInSyn1;
    float* inSynInSyn1;
    unsigned int* denDelayPtrInSyn0;
    float* denDelayInSyn0;
    float* inSynInSyn0;
    scalar* RefracTime;
    scalar* V;
    unsigned int* spk;
    unsigned int* spkCnt;
    unsigned int numNeurons;
    
}
;
struct MergedNeuronInitGroup2
 {
    float* inSynInSyn2;
    unsigned int* denDelayPtrInSyn5;
    float* denDelayInSyn5;
    float* inSynInSyn5;
    unsigned int* denDelayPtrInSyn4;
    float* denDelayInSyn4;
    float* inSynInSyn4;
    unsigned int* denDelayPtrInSyn3;
    float* denDelayInSyn3;
    float* inSynInSyn3;
    unsigned int* denDelayPtrInSyn2;
    float* denDelayInSyn2;
    unsigned int* denDelayPtrInSyn1;
    float* denDelayInSyn1;
    float* inSynInSyn1;
    unsigned int* denDelayPtrInSyn0;
    float* denDelayInSyn0;
    float* inSynInSyn0;
    scalar* RefracTime;
    scalar* V;
    unsigned int* spk;
    unsigned int* spkCnt;
    unsigned int numNeurons;
    
}
;
struct MergedNeuronInitGroup3
 {
    float* inSynInSyn11;
    float* inSynInSyn7;
    float* denDelayInSyn7;
    unsigned int* denDelayPtrInSyn7;
    float* inSynInSyn8;
    float* denDelayInSyn8;
    unsigned int* denDelayPtrInSyn8;
    float* inSynInSyn9;
    float* denDelayInSyn9;
    unsigned int* denDelayPtrInSyn9;
    float* inSynInSyn10;
    float* denDelayInSyn10;
    unsigned int* denDelayPtrInSyn10;
    unsigned int* denDelayPtrInSyn6;
    float* denDelayInSyn11;
    unsigned int* denDelayPtrInSyn11;
    float* inSynInSyn12;
    float* denDelayInSyn12;
    unsigned int* denDelayPtrInSyn12;
    float* inSynInSyn13;
    float* denDelayInSyn13;
    unsigned int* denDelayPtrInSyn13;
    float* inSynInSyn14;
    float* denDelayInSyn14;
    unsigned int* denDelayPtrInSyn14;
    unsigned int* denDelayPtrInSyn2;
    unsigned int* spkCnt;
    unsigned int* spk;
    scalar* V;
    scalar* RefracTime;
    float* inSynInSyn0;
    float* denDelayInSyn0;
    unsigned int* denDelayPtrInSyn0;
    float* inSynInSyn1;
    float* denDelayInSyn1;
    unsigned int* denDelayPtrInSyn1;
    float* inSynInSyn2;
    float* denDelayInSyn2;
    float* inSynInSyn3;
    float* denDelayInSyn3;
    unsigned int* denDelayPtrInSyn3;
    float* inSynInSyn4;
    float* denDelayInSyn4;
    unsigned int* denDelayPtrInSyn4;
    float* inSynInSyn5;
    float* denDelayInSyn5;
    unsigned int* denDelayPtrInSyn5;
    float* inSynInSyn6;
    float* denDelayInSyn6;
    unsigned int numNeurons;
    
}
;
struct MergedNeuronInitGroup4
 {
    float* denDelayInSyn9;
    float* inSynInSyn6;
    float* denDelayInSyn6;
    unsigned int* denDelayPtrInSyn6;
    float* inSynInSyn7;
    float* denDelayInSyn7;
    unsigned int* denDelayPtrInSyn7;
    float* inSynInSyn8;
    float* denDelayInSyn8;
    unsigned int* denDelayPtrInSyn8;
    float* inSynInSyn9;
    unsigned int* denDelayPtrInSyn5;
    unsigned int* denDelayPtrInSyn9;
    float* inSynInSyn10;
    float* denDelayInSyn10;
    unsigned int* denDelayPtrInSyn10;
    float* inSynInSyn11;
    float* denDelayInSyn11;
    unsigned int* denDelayPtrInSyn11;
    float* inSynInSyn12;
    float* denDelayInSyn12;
    unsigned int* denDelayPtrInSyn12;
    float* inSynInSyn2;
    unsigned int* spkCnt;
    unsigned int* spk;
    scalar* V;
    scalar* RefracTime;
    float* inSynInSyn0;
    float* denDelayInSyn0;
    unsigned int* denDelayPtrInSyn0;
    float* inSynInSyn1;
    float* denDelayInSyn1;
    unsigned int* denDelayPtrInSyn1;
    float* denDelayInSyn2;
    unsigned int* denDelayPtrInSyn2;
    float* inSynInSyn3;
    float* denDelayInSyn3;
    unsigned int* denDelayPtrInSyn3;
    float* inSynInSyn4;
    float* denDelayInSyn4;
    unsigned int* denDelayPtrInSyn4;
    float* inSynInSyn5;
    float* denDelayInSyn5;
    unsigned int numNeurons;
    
}
;
struct MergedNeuronInitGroup5
 {
    float* inSynInSyn8;
    float* inSynInSyn5;
    float* denDelayInSyn5;
    unsigned int* denDelayPtrInSyn5;
    float* inSynInSyn6;
    float* denDelayInSyn6;
    unsigned int* denDelayPtrInSyn6;
    float* inSynInSyn7;
    float* denDelayInSyn7;
    unsigned int* denDelayPtrInSyn7;
    unsigned int* denDelayPtrInSyn4;
    float* denDelayInSyn8;
    unsigned int* denDelayPtrInSyn8;
    float* inSynInSyn9;
    float* denDelayInSyn9;
    unsigned int* denDelayPtrInSyn9;
    float* inSynInSyn10;
    float* denDelayInSyn10;
    unsigned int* denDelayPtrInSyn10;
    unsigned int* denDelayPtrInSyn1;
    unsigned int* spkCnt;
    unsigned int* spk;
    scalar* V;
    scalar* RefracTime;
    float* inSynInSyn0;
    float* denDelayInSyn0;
    unsigned int* denDelayPtrInSyn0;
    float* inSynInSyn1;
    float* denDelayInSyn1;
    float* inSynInSyn2;
    float* denDelayInSyn2;
    unsigned int* denDelayPtrInSyn2;
    float* inSynInSyn3;
    float* denDelayInSyn3;
    unsigned int* denDelayPtrInSyn3;
    float* inSynInSyn4;
    float* denDelayInSyn4;
    unsigned int numNeurons;
    
}
;
struct MergedNeuronInitGroup6
 {
    float* inSynInSyn7;
    float* denDelayInSyn4;
    unsigned int* denDelayPtrInSyn4;
    float* inSynInSyn5;
    float* denDelayInSyn5;
    unsigned int* denDelayPtrInSyn5;
    float* inSynInSyn6;
    float* denDelayInSyn6;
    unsigned int* denDelayPtrInSyn6;
    float* inSynInSyn4;
    float* denDelayInSyn7;
    unsigned int* denDelayPtrInSyn7;
    float* inSynInSyn8;
    float* denDelayInSyn8;
    unsigned int* denDelayPtrInSyn8;
    float* inSynInSyn9;
    float* denDelayInSyn9;
    unsigned int* denDelayPtrInSyn9;
    float* denDelayInSyn1;
    unsigned int* spkCnt;
    unsigned int* spk;
    scalar* V;
    scalar* RefracTime;
    float* inSynInSyn0;
    float* denDelayInSyn0;
    unsigned int* denDelayPtrInSyn0;
    float* inSynInSyn1;
    unsigned int* denDelayPtrInSyn1;
    float* inSynInSyn2;
    float* denDelayInSyn2;
    unsigned int* denDelayPtrInSyn2;
    float* inSynInSyn3;
    float* denDelayInSyn3;
    unsigned int* denDelayPtrInSyn3;
    unsigned int numNeurons;
    
}
;
struct MergedNeuronInitGroup7
 {
    unsigned int* denDelayPtrInSyn8;
    float* denDelayInSyn5;
    unsigned int* denDelayPtrInSyn5;
    float* inSynInSyn6;
    float* denDelayInSyn6;
    unsigned int* denDelayPtrInSyn6;
    float* inSynInSyn7;
    float* denDelayInSyn7;
    unsigned int* denDelayPtrInSyn7;
    float* inSynInSyn8;
    float* denDelayInSyn8;
    float* inSynInSyn5;
    float* inSynInSyn9;
    float* denDelayInSyn9;
    unsigned int* denDelayPtrInSyn9;
    float* inSynInSyn10;
    float* denDelayInSyn10;
    unsigned int* denDelayPtrInSyn10;
    float* inSynInSyn11;
    float* denDelayInSyn11;
    unsigned int* denDelayPtrInSyn11;
    unsigned int* denDelayPtrInSyn1;
    unsigned int* spkCnt;
    unsigned int* spk;
    scalar* V;
    scalar* RefracTime;
    float* inSynInSyn0;
    float* denDelayInSyn0;
    unsigned int* denDelayPtrInSyn0;
    float* inSynInSyn1;
    float* denDelayInSyn1;
    float* inSynInSyn2;
    float* denDelayInSyn2;
    unsigned int* denDelayPtrInSyn2;
    float* inSynInSyn3;
    float* denDelayInSyn3;
    unsigned int* denDelayPtrInSyn3;
    float* inSynInSyn4;
    float* denDelayInSyn4;
    unsigned int* denDelayPtrInSyn4;
    unsigned int numNeurons;
    
}
;
struct MergedSynapseConnectivityInitGroup0
 {
    unsigned int* rowLength;
    uint32_t* ind;
    uint16_t* preCalcRowLength;
    unsigned int numSrcNeurons;
    unsigned int numTrgNeurons;
    unsigned int rowStride;
    
}
;
struct MergedSynapseSparseInitGroup0
 {
    unsigned int* rowLength;
    uint32_t* ind;
    scalar* g;
    uint8_t* d;
    unsigned int numSrcNeurons;
    unsigned int numTrgNeurons;
    unsigned int rowStride;
    unsigned int colStride;
    scalar meang;
    scalar sdg;
    scalar ming;
    scalar maxg;
    scalar meanTimestepd;
    scalar sdTimestepd;
    scalar maxTimestepd;
    
}
;
__device__ __constant__ MergedNeuronInitGroup0 d_mergedNeuronInitGroup0[1];
void pushMergedNeuronInitGroup0ToDevice(unsigned int idx, float* inSynInSyn10, float* denDelayInSyn6, unsigned int* denDelayPtrInSyn6, float* inSynInSyn7, float* denDelayInSyn7, unsigned int* denDelayPtrInSyn7, float* inSynInSyn8, float* denDelayInSyn8, unsigned int* denDelayPtrInSyn8, float* inSynInSyn9, float* denDelayInSyn9, unsigned int* denDelayPtrInSyn9, float* inSynInSyn6, float* denDelayInSyn10, unsigned int* denDelayPtrInSyn10, float* inSynInSyn11, float* denDelayInSyn11, unsigned int* denDelayPtrInSyn11, float* inSynInSyn12, float* denDelayInSyn12, unsigned int* denDelayPtrInSyn12, float* inSynInSyn13, float* denDelayInSyn13, unsigned int* denDelayPtrInSyn13, float* denDelayInSyn2, unsigned int* spkCnt, unsigned int* spk, scalar* V, scalar* RefracTime, float* inSynInSyn0, float* denDelayInSyn0, unsigned int* denDelayPtrInSyn0, float* inSynInSyn1, float* denDelayInSyn1, unsigned int* denDelayPtrInSyn1, float* inSynInSyn2, unsigned int* denDelayPtrInSyn2, float* inSynInSyn3, float* denDelayInSyn3, unsigned int* denDelayPtrInSyn3, float* inSynInSyn4, float* denDelayInSyn4, unsigned int* denDelayPtrInSyn4, float* inSynInSyn5, float* denDelayInSyn5, unsigned int* denDelayPtrInSyn5, unsigned int numNeurons) {
    MergedNeuronInitGroup0 group = {inSynInSyn10, denDelayInSyn6, denDelayPtrInSyn6, inSynInSyn7, denDelayInSyn7, denDelayPtrInSyn7, inSynInSyn8, denDelayInSyn8, denDelayPtrInSyn8, inSynInSyn9, denDelayInSyn9, denDelayPtrInSyn9, inSynInSyn6, denDelayInSyn10, denDelayPtrInSyn10, inSynInSyn11, denDelayInSyn11, denDelayPtrInSyn11, inSynInSyn12, denDelayInSyn12, denDelayPtrInSyn12, inSynInSyn13, denDelayInSyn13, denDelayPtrInSyn13, denDelayInSyn2, spkCnt, spk, V, RefracTime, inSynInSyn0, denDelayInSyn0, denDelayPtrInSyn0, inSynInSyn1, denDelayInSyn1, denDelayPtrInSyn1, inSynInSyn2, denDelayPtrInSyn2, inSynInSyn3, denDelayInSyn3, denDelayPtrInSyn3, inSynInSyn4, denDelayInSyn4, denDelayPtrInSyn4, inSynInSyn5, denDelayInSyn5, denDelayPtrInSyn5, numNeurons, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronInitGroup0, &group, sizeof(MergedNeuronInitGroup0), idx * sizeof(MergedNeuronInitGroup0)));
}
__device__ __constant__ MergedNeuronInitGroup1 d_mergedNeuronInitGroup1[3];
void pushMergedNeuronInitGroup1ToDevice(unsigned int idx, float* inSynInSyn3, unsigned int* denDelayPtrInSyn7, float* denDelayInSyn7, float* inSynInSyn7, unsigned int* denDelayPtrInSyn6, float* denDelayInSyn6, float* inSynInSyn6, unsigned int* denDelayPtrInSyn5, float* denDelayInSyn5, float* inSynInSyn5, unsigned int* denDelayPtrInSyn4, float* denDelayInSyn4, float* inSynInSyn4, unsigned int* denDelayPtrInSyn3, float* denDelayInSyn3, unsigned int* denDelayPtrInSyn2, float* denDelayInSyn2, float* inSynInSyn2, unsigned int* denDelayPtrInSyn1, float* denDelayInSyn1, float* inSynInSyn1, unsigned int* denDelayPtrInSyn0, float* denDelayInSyn0, float* inSynInSyn0, scalar* RefracTime, scalar* V, unsigned int* spk, unsigned int* spkCnt, unsigned int numNeurons) {
    MergedNeuronInitGroup1 group = {inSynInSyn3, denDelayPtrInSyn7, denDelayInSyn7, inSynInSyn7, denDelayPtrInSyn6, denDelayInSyn6, inSynInSyn6, denDelayPtrInSyn5, denDelayInSyn5, inSynInSyn5, denDelayPtrInSyn4, denDelayInSyn4, inSynInSyn4, denDelayPtrInSyn3, denDelayInSyn3, denDelayPtrInSyn2, denDelayInSyn2, inSynInSyn2, denDelayPtrInSyn1, denDelayInSyn1, inSynInSyn1, denDelayPtrInSyn0, denDelayInSyn0, inSynInSyn0, RefracTime, V, spk, spkCnt, numNeurons, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronInitGroup1, &group, sizeof(MergedNeuronInitGroup1), idx * sizeof(MergedNeuronInitGroup1)));
}
__device__ __constant__ MergedNeuronInitGroup2 d_mergedNeuronInitGroup2[1];
void pushMergedNeuronInitGroup2ToDevice(unsigned int idx, float* inSynInSyn2, unsigned int* denDelayPtrInSyn5, float* denDelayInSyn5, float* inSynInSyn5, unsigned int* denDelayPtrInSyn4, float* denDelayInSyn4, float* inSynInSyn4, unsigned int* denDelayPtrInSyn3, float* denDelayInSyn3, float* inSynInSyn3, unsigned int* denDelayPtrInSyn2, float* denDelayInSyn2, unsigned int* denDelayPtrInSyn1, float* denDelayInSyn1, float* inSynInSyn1, unsigned int* denDelayPtrInSyn0, float* denDelayInSyn0, float* inSynInSyn0, scalar* RefracTime, scalar* V, unsigned int* spk, unsigned int* spkCnt, unsigned int numNeurons) {
    MergedNeuronInitGroup2 group = {inSynInSyn2, denDelayPtrInSyn5, denDelayInSyn5, inSynInSyn5, denDelayPtrInSyn4, denDelayInSyn4, inSynInSyn4, denDelayPtrInSyn3, denDelayInSyn3, inSynInSyn3, denDelayPtrInSyn2, denDelayInSyn2, denDelayPtrInSyn1, denDelayInSyn1, inSynInSyn1, denDelayPtrInSyn0, denDelayInSyn0, inSynInSyn0, RefracTime, V, spk, spkCnt, numNeurons, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronInitGroup2, &group, sizeof(MergedNeuronInitGroup2), idx * sizeof(MergedNeuronInitGroup2)));
}
__device__ __constant__ MergedNeuronInitGroup3 d_mergedNeuronInitGroup3[1];
void pushMergedNeuronInitGroup3ToDevice(unsigned int idx, float* inSynInSyn11, float* inSynInSyn7, float* denDelayInSyn7, unsigned int* denDelayPtrInSyn7, float* inSynInSyn8, float* denDelayInSyn8, unsigned int* denDelayPtrInSyn8, float* inSynInSyn9, float* denDelayInSyn9, unsigned int* denDelayPtrInSyn9, float* inSynInSyn10, float* denDelayInSyn10, unsigned int* denDelayPtrInSyn10, unsigned int* denDelayPtrInSyn6, float* denDelayInSyn11, unsigned int* denDelayPtrInSyn11, float* inSynInSyn12, float* denDelayInSyn12, unsigned int* denDelayPtrInSyn12, float* inSynInSyn13, float* denDelayInSyn13, unsigned int* denDelayPtrInSyn13, float* inSynInSyn14, float* denDelayInSyn14, unsigned int* denDelayPtrInSyn14, unsigned int* denDelayPtrInSyn2, unsigned int* spkCnt, unsigned int* spk, scalar* V, scalar* RefracTime, float* inSynInSyn0, float* denDelayInSyn0, unsigned int* denDelayPtrInSyn0, float* inSynInSyn1, float* denDelayInSyn1, unsigned int* denDelayPtrInSyn1, float* inSynInSyn2, float* denDelayInSyn2, float* inSynInSyn3, float* denDelayInSyn3, unsigned int* denDelayPtrInSyn3, float* inSynInSyn4, float* denDelayInSyn4, unsigned int* denDelayPtrInSyn4, float* inSynInSyn5, float* denDelayInSyn5, unsigned int* denDelayPtrInSyn5, float* inSynInSyn6, float* denDelayInSyn6, unsigned int numNeurons) {
    MergedNeuronInitGroup3 group = {inSynInSyn11, inSynInSyn7, denDelayInSyn7, denDelayPtrInSyn7, inSynInSyn8, denDelayInSyn8, denDelayPtrInSyn8, inSynInSyn9, denDelayInSyn9, denDelayPtrInSyn9, inSynInSyn10, denDelayInSyn10, denDelayPtrInSyn10, denDelayPtrInSyn6, denDelayInSyn11, denDelayPtrInSyn11, inSynInSyn12, denDelayInSyn12, denDelayPtrInSyn12, inSynInSyn13, denDelayInSyn13, denDelayPtrInSyn13, inSynInSyn14, denDelayInSyn14, denDelayPtrInSyn14, denDelayPtrInSyn2, spkCnt, spk, V, RefracTime, inSynInSyn0, denDelayInSyn0, denDelayPtrInSyn0, inSynInSyn1, denDelayInSyn1, denDelayPtrInSyn1, inSynInSyn2, denDelayInSyn2, inSynInSyn3, denDelayInSyn3, denDelayPtrInSyn3, inSynInSyn4, denDelayInSyn4, denDelayPtrInSyn4, inSynInSyn5, denDelayInSyn5, denDelayPtrInSyn5, inSynInSyn6, denDelayInSyn6, numNeurons, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronInitGroup3, &group, sizeof(MergedNeuronInitGroup3), idx * sizeof(MergedNeuronInitGroup3)));
}
__device__ __constant__ MergedNeuronInitGroup4 d_mergedNeuronInitGroup4[1];
void pushMergedNeuronInitGroup4ToDevice(unsigned int idx, float* denDelayInSyn9, float* inSynInSyn6, float* denDelayInSyn6, unsigned int* denDelayPtrInSyn6, float* inSynInSyn7, float* denDelayInSyn7, unsigned int* denDelayPtrInSyn7, float* inSynInSyn8, float* denDelayInSyn8, unsigned int* denDelayPtrInSyn8, float* inSynInSyn9, unsigned int* denDelayPtrInSyn5, unsigned int* denDelayPtrInSyn9, float* inSynInSyn10, float* denDelayInSyn10, unsigned int* denDelayPtrInSyn10, float* inSynInSyn11, float* denDelayInSyn11, unsigned int* denDelayPtrInSyn11, float* inSynInSyn12, float* denDelayInSyn12, unsigned int* denDelayPtrInSyn12, float* inSynInSyn2, unsigned int* spkCnt, unsigned int* spk, scalar* V, scalar* RefracTime, float* inSynInSyn0, float* denDelayInSyn0, unsigned int* denDelayPtrInSyn0, float* inSynInSyn1, float* denDelayInSyn1, unsigned int* denDelayPtrInSyn1, float* denDelayInSyn2, unsigned int* denDelayPtrInSyn2, float* inSynInSyn3, float* denDelayInSyn3, unsigned int* denDelayPtrInSyn3, float* inSynInSyn4, float* denDelayInSyn4, unsigned int* denDelayPtrInSyn4, float* inSynInSyn5, float* denDelayInSyn5, unsigned int numNeurons) {
    MergedNeuronInitGroup4 group = {denDelayInSyn9, inSynInSyn6, denDelayInSyn6, denDelayPtrInSyn6, inSynInSyn7, denDelayInSyn7, denDelayPtrInSyn7, inSynInSyn8, denDelayInSyn8, denDelayPtrInSyn8, inSynInSyn9, denDelayPtrInSyn5, denDelayPtrInSyn9, inSynInSyn10, denDelayInSyn10, denDelayPtrInSyn10, inSynInSyn11, denDelayInSyn11, denDelayPtrInSyn11, inSynInSyn12, denDelayInSyn12, denDelayPtrInSyn12, inSynInSyn2, spkCnt, spk, V, RefracTime, inSynInSyn0, denDelayInSyn0, denDelayPtrInSyn0, inSynInSyn1, denDelayInSyn1, denDelayPtrInSyn1, denDelayInSyn2, denDelayPtrInSyn2, inSynInSyn3, denDelayInSyn3, denDelayPtrInSyn3, inSynInSyn4, denDelayInSyn4, denDelayPtrInSyn4, inSynInSyn5, denDelayInSyn5, numNeurons, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronInitGroup4, &group, sizeof(MergedNeuronInitGroup4), idx * sizeof(MergedNeuronInitGroup4)));
}
__device__ __constant__ MergedNeuronInitGroup5 d_mergedNeuronInitGroup5[2];
void pushMergedNeuronInitGroup5ToDevice(unsigned int idx, float* inSynInSyn8, float* inSynInSyn5, float* denDelayInSyn5, unsigned int* denDelayPtrInSyn5, float* inSynInSyn6, float* denDelayInSyn6, unsigned int* denDelayPtrInSyn6, float* inSynInSyn7, float* denDelayInSyn7, unsigned int* denDelayPtrInSyn7, unsigned int* denDelayPtrInSyn4, float* denDelayInSyn8, unsigned int* denDelayPtrInSyn8, float* inSynInSyn9, float* denDelayInSyn9, unsigned int* denDelayPtrInSyn9, float* inSynInSyn10, float* denDelayInSyn10, unsigned int* denDelayPtrInSyn10, unsigned int* denDelayPtrInSyn1, unsigned int* spkCnt, unsigned int* spk, scalar* V, scalar* RefracTime, float* inSynInSyn0, float* denDelayInSyn0, unsigned int* denDelayPtrInSyn0, float* inSynInSyn1, float* denDelayInSyn1, float* inSynInSyn2, float* denDelayInSyn2, unsigned int* denDelayPtrInSyn2, float* inSynInSyn3, float* denDelayInSyn3, unsigned int* denDelayPtrInSyn3, float* inSynInSyn4, float* denDelayInSyn4, unsigned int numNeurons) {
    MergedNeuronInitGroup5 group = {inSynInSyn8, inSynInSyn5, denDelayInSyn5, denDelayPtrInSyn5, inSynInSyn6, denDelayInSyn6, denDelayPtrInSyn6, inSynInSyn7, denDelayInSyn7, denDelayPtrInSyn7, denDelayPtrInSyn4, denDelayInSyn8, denDelayPtrInSyn8, inSynInSyn9, denDelayInSyn9, denDelayPtrInSyn9, inSynInSyn10, denDelayInSyn10, denDelayPtrInSyn10, denDelayPtrInSyn1, spkCnt, spk, V, RefracTime, inSynInSyn0, denDelayInSyn0, denDelayPtrInSyn0, inSynInSyn1, denDelayInSyn1, inSynInSyn2, denDelayInSyn2, denDelayPtrInSyn2, inSynInSyn3, denDelayInSyn3, denDelayPtrInSyn3, inSynInSyn4, denDelayInSyn4, numNeurons, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronInitGroup5, &group, sizeof(MergedNeuronInitGroup5), idx * sizeof(MergedNeuronInitGroup5)));
}
__device__ __constant__ MergedNeuronInitGroup6 d_mergedNeuronInitGroup6[2];
void pushMergedNeuronInitGroup6ToDevice(unsigned int idx, float* inSynInSyn7, float* denDelayInSyn4, unsigned int* denDelayPtrInSyn4, float* inSynInSyn5, float* denDelayInSyn5, unsigned int* denDelayPtrInSyn5, float* inSynInSyn6, float* denDelayInSyn6, unsigned int* denDelayPtrInSyn6, float* inSynInSyn4, float* denDelayInSyn7, unsigned int* denDelayPtrInSyn7, float* inSynInSyn8, float* denDelayInSyn8, unsigned int* denDelayPtrInSyn8, float* inSynInSyn9, float* denDelayInSyn9, unsigned int* denDelayPtrInSyn9, float* denDelayInSyn1, unsigned int* spkCnt, unsigned int* spk, scalar* V, scalar* RefracTime, float* inSynInSyn0, float* denDelayInSyn0, unsigned int* denDelayPtrInSyn0, float* inSynInSyn1, unsigned int* denDelayPtrInSyn1, float* inSynInSyn2, float* denDelayInSyn2, unsigned int* denDelayPtrInSyn2, float* inSynInSyn3, float* denDelayInSyn3, unsigned int* denDelayPtrInSyn3, unsigned int numNeurons) {
    MergedNeuronInitGroup6 group = {inSynInSyn7, denDelayInSyn4, denDelayPtrInSyn4, inSynInSyn5, denDelayInSyn5, denDelayPtrInSyn5, inSynInSyn6, denDelayInSyn6, denDelayPtrInSyn6, inSynInSyn4, denDelayInSyn7, denDelayPtrInSyn7, inSynInSyn8, denDelayInSyn8, denDelayPtrInSyn8, inSynInSyn9, denDelayInSyn9, denDelayPtrInSyn9, denDelayInSyn1, spkCnt, spk, V, RefracTime, inSynInSyn0, denDelayInSyn0, denDelayPtrInSyn0, inSynInSyn1, denDelayPtrInSyn1, inSynInSyn2, denDelayInSyn2, denDelayPtrInSyn2, inSynInSyn3, denDelayInSyn3, denDelayPtrInSyn3, numNeurons, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronInitGroup6, &group, sizeof(MergedNeuronInitGroup6), idx * sizeof(MergedNeuronInitGroup6)));
}
__device__ __constant__ MergedNeuronInitGroup7 d_mergedNeuronInitGroup7[6];
void pushMergedNeuronInitGroup7ToDevice(unsigned int idx, unsigned int* denDelayPtrInSyn8, float* denDelayInSyn5, unsigned int* denDelayPtrInSyn5, float* inSynInSyn6, float* denDelayInSyn6, unsigned int* denDelayPtrInSyn6, float* inSynInSyn7, float* denDelayInSyn7, unsigned int* denDelayPtrInSyn7, float* inSynInSyn8, float* denDelayInSyn8, float* inSynInSyn5, float* inSynInSyn9, float* denDelayInSyn9, unsigned int* denDelayPtrInSyn9, float* inSynInSyn10, float* denDelayInSyn10, unsigned int* denDelayPtrInSyn10, float* inSynInSyn11, float* denDelayInSyn11, unsigned int* denDelayPtrInSyn11, unsigned int* denDelayPtrInSyn1, unsigned int* spkCnt, unsigned int* spk, scalar* V, scalar* RefracTime, float* inSynInSyn0, float* denDelayInSyn0, unsigned int* denDelayPtrInSyn0, float* inSynInSyn1, float* denDelayInSyn1, float* inSynInSyn2, float* denDelayInSyn2, unsigned int* denDelayPtrInSyn2, float* inSynInSyn3, float* denDelayInSyn3, unsigned int* denDelayPtrInSyn3, float* inSynInSyn4, float* denDelayInSyn4, unsigned int* denDelayPtrInSyn4, unsigned int numNeurons) {
    MergedNeuronInitGroup7 group = {denDelayPtrInSyn8, denDelayInSyn5, denDelayPtrInSyn5, inSynInSyn6, denDelayInSyn6, denDelayPtrInSyn6, inSynInSyn7, denDelayInSyn7, denDelayPtrInSyn7, inSynInSyn8, denDelayInSyn8, inSynInSyn5, inSynInSyn9, denDelayInSyn9, denDelayPtrInSyn9, inSynInSyn10, denDelayInSyn10, denDelayPtrInSyn10, inSynInSyn11, denDelayInSyn11, denDelayPtrInSyn11, denDelayPtrInSyn1, spkCnt, spk, V, RefracTime, inSynInSyn0, denDelayInSyn0, denDelayPtrInSyn0, inSynInSyn1, denDelayInSyn1, inSynInSyn2, denDelayInSyn2, denDelayPtrInSyn2, inSynInSyn3, denDelayInSyn3, denDelayPtrInSyn3, inSynInSyn4, denDelayInSyn4, denDelayPtrInSyn4, numNeurons, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronInitGroup7, &group, sizeof(MergedNeuronInitGroup7), idx * sizeof(MergedNeuronInitGroup7)));
}
__device__ __constant__ MergedSynapseConnectivityInitGroup0 d_mergedSynapseConnectivityInitGroup0[186];
void pushMergedSynapseConnectivityInitGroup0ToDevice(unsigned int idx, unsigned int* rowLength, uint32_t* ind, uint16_t* preCalcRowLength, unsigned int numSrcNeurons, unsigned int numTrgNeurons, unsigned int rowStride) {
    MergedSynapseConnectivityInitGroup0 group = {rowLength, ind, preCalcRowLength, numSrcNeurons, numTrgNeurons, rowStride, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedSynapseConnectivityInitGroup0, &group, sizeof(MergedSynapseConnectivityInitGroup0), idx * sizeof(MergedSynapseConnectivityInitGroup0)));
}
__device__ __constant__ MergedSynapseSparseInitGroup0 d_mergedSynapseSparseInitGroup0[186];
void pushMergedSynapseSparseInitGroup0ToDevice(unsigned int idx, unsigned int* rowLength, uint32_t* ind, scalar* g, uint8_t* d, unsigned int numSrcNeurons, unsigned int numTrgNeurons, unsigned int rowStride, unsigned int colStride, scalar meang, scalar sdg, scalar ming, scalar maxg, scalar meanTimestepd, scalar sdTimestepd, scalar maxTimestepd) {
    MergedSynapseSparseInitGroup0 group = {rowLength, ind, g, d, numSrcNeurons, numTrgNeurons, rowStride, colStride, meang, sdg, ming, maxg, meanTimestepd, sdTimestepd, maxTimestepd, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedSynapseSparseInitGroup0, &group, sizeof(MergedSynapseSparseInitGroup0), idx * sizeof(MergedSynapseSparseInitGroup0)));
}
// ------------------------------------------------------------------------
// merged extra global parameter functions
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// merged extra global parameter functions
// ------------------------------------------------------------------------
void pushMergedSynapseConnectivityInit0preCalcRowLengthToDevice(unsigned int idx, uint16_t* value) {
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedSynapseConnectivityInitGroup0, &value, sizeof(value), (sizeof(MergedSynapseConnectivityInitGroup0) * (idx)) + offsetof(MergedSynapseConnectivityInitGroup0, preCalcRowLength)));
}

// ------------------------------------------------------------------------
// merged extra global parameter functions
// ------------------------------------------------------------------------
__device__ unsigned int d_mergedNeuronInitGroupStartID0[] = {0, };
__device__ unsigned int d_mergedNeuronInitGroupStartID1[] = {1760, 3424, 5120, };
__device__ unsigned int d_mergedNeuronInitGroupStartID2[] = {5440, };
__device__ unsigned int d_mergedNeuronInitGroupStartID3[] = {20992, };
__device__ unsigned int d_mergedNeuronInitGroupStartID4[] = {42624, };
__device__ unsigned int d_mergedNeuronInitGroupStartID5[] = {117568, 120192, };
__device__ unsigned int d_mergedNeuronInitGroupStartID6[] = {122112, 142400, };
__device__ unsigned int d_mergedNeuronInitGroupStartID7[] = {146944, 198688, 205728, 209792, 211392, 213376, };
__device__ unsigned int d_mergedSynapseConnectivityInitGroupStartID0[] = {213728, 265472, 317216, 368960, 420704, 472448, 524192, 575936, 627680, 679424, 731168, 782912, 857856, 932800, 1007744, 1082688, 1157632, 1232576, 1307520, 1382464, 1457408, 1532352, 1607296, 1682240, 1757184, 1778816, 1800448, 1822080, 1843712, 1865344, 1886976, 1908608, 1930240, 1951872, 1973504, 1995136, 2016768, 2038400, 2060032, 2081664, 2103296, 2124928, 2145216, 2165504, 2185792, 2206080, 2226368, 2246656, 2266944, 2287232, 2302784, 2318336, 2333888, 2349440, 2364992, 2380544, 2396096, 2411648, 2414272, 2416896, 2419520, 2422144, 2424768, 2427392, 2430016, 2432640, 2435264, 2437888, 2440512, 2447552, 2454592, 2461632, 2468672, 2475712, 2482752, 2489792, 2496832, 2503872, 2510912, 2517952, 2524992, 2526752, 2528512, 2530272, 2532032, 2533792, 2535552, 2537312, 2539072, 2540832, 2542592, 2544352, 2546112, 2547776, 2549440, 2551104, 2552768, 2554432, 2556096, 2557760, 2559424, 2561088, 2562752, 2564672, 2566592, 2568512, 2570432, 2572352, 2574272, 2576192, 2578112, 2580032, 2581952, 2586016, 2590080, 2594144, 2598208, 2602272, 2606336, 2610400, 2614464, 2618528, 2622592, 2626656, 2630720, 2632320, 2633920, 2635520, 2637120, 2638720, 2640320, 2641920, 2643520, 2645120, 2646720, 2648320, 2649920, 2651520, 2653120, 2654720, 2656416, 2658112, 2659808, 2661504, 2663200, 2664896, 2666592, 2668288, 2672832, 2677376, 2681920, 2686464, 2691008, 2695552, 2700096, 2704640, 2706624, 2708608, 2710592, 2712576, 2714560, 2716544, 2718528, 2720512, 2722496, 2724480, 2726464, 2726816, 2727168, 2727520, 2727872, 2728224, 2728576, 2728928, 2729280, 2729632, 2729984, 2730336, 2730688, 2731008, 2731328, 2731648, 2731968, 2732288, 2732608, 2732928, };
__device__ unsigned int d_mergedSynapseSparseInitGroupStartID0[] = {0, 1152, 1408, 1728, 1984, 2112, 2176, 2304, 2432, 2496, 2624, 2688, 3328, 4736, 4992, 5120, 5184, 5504, 5568, 5632, 5888, 5952, 6080, 6272, 6336, 6656, 6848, 7424, 7680, 7808, 7872, 8000, 8064, 8128, 8192, 8320, 8384, 8448, 8576, 8640, 8704, 8768, 8960, 9216, 9280, 9408, 9472, 9600, 9664, 9728, 10496, 10944, 11136, 11328, 11840, 11904, 11968, 12096, 14976, 15552, 15808, 15936, 16192, 16320, 16384, 16448, 16512, 16704, 16768, 17792, 20288, 20480, 20544, 20864, 20928, 20992, 21056, 21120, 21184, 21248, 21312, 23296, 23488, 23616, 23744, 23936, 24000, 24064, 24128, 24192, 24256, 24320, 24384, 26176, 28672, 29504, 30272, 30336, 30464, 30528, 30656, 30720, 30784, 33792, 34368, 34496, 35136, 35584, 35712, 35776, 35840, 36416, 36480, 37504, 39552, 39680, 40064, 40128, 40704, 40768, 40832, 40896, 40960, 41152, 41216, 42880, 43712, 45120, 45312, 46016, 46144, 46528, 46592, 46656, 46720, 46784, 46848, 46912, 47040, 47104, 47424, 48192, 48256, 48320, 48384, 48448, 48512, 48576, 49280, 49856, 49920, 50048, 50304, 50368, 50432, 50496, 51520, 53568, 53632, 53696, 53760, 53824, 54080, 54144, 54208, 54272, 54336, 54848, 55424, 55616, 55744, 55808, 55872, 55936, 56192, 56256, 56320, 56384, 56448, 56768, 57536, 57600, 57664, 57728, 57792, 57856, };

extern "C" __global__ void initializeRNGKernel(unsigned long long deviceRNGSeed) {
    if(threadIdx.x == 0) {
        curand_init(deviceRNGSeed, 0, 0, &d_rng);
    }
}

extern "C" __global__ void initializeKernel(unsigned long long deviceRNGSeed) {
    const unsigned int id = 32 * blockIdx.x + threadIdx.x;
    // ------------------------------------------------------------------------
    // Local neuron groups
    // merged0
    if(id < 1760) {
        struct MergedNeuronInitGroup0 *group = &d_mergedNeuronInitGroup0[0]; 
        const unsigned int lid = id - 0;
        // only do this for existing neurons
        if(lid < group->numNeurons) {
            curandStatePhilox4_32_10_t localRNG = d_rng;
            skipahead_sequence((unsigned long long)id, &localRNG);
            if(lid == 0) {
                group->spkCnt[0] = 0;
            }
            group->spk[lid] = 0;
             {
                scalar initVal;
                initVal = (-1.50000000000000000e+02f) + (curand_normal(&localRNG) * (5.00000000000000000e+01f));
                group->V[lid] = initVal;
            }
             {
                scalar initVal;
                initVal = (0.00000000000000000e+00f);
                group->RefracTime[lid] = initVal;
            }
             {
                group->inSynInSyn0[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn0[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn0 = 0;
                }
            }
             {
                group->inSynInSyn1[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn1[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn1 = 0;
                }
            }
             {
                group->inSynInSyn2[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn2[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn2 = 0;
                }
            }
             {
                group->inSynInSyn3[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn3[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn3 = 0;
                }
            }
             {
                group->inSynInSyn4[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn4[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn4 = 0;
                }
            }
             {
                group->inSynInSyn5[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn5[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn5 = 0;
                }
            }
             {
                group->inSynInSyn6[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn6[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn6 = 0;
                }
            }
             {
                group->inSynInSyn7[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn7[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn7 = 0;
                }
            }
             {
                group->inSynInSyn8[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn8[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn8 = 0;
                }
            }
             {
                group->inSynInSyn9[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn9[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn9 = 0;
                }
            }
             {
                group->inSynInSyn10[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn10[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn10 = 0;
                }
            }
             {
                group->inSynInSyn11[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn11[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn11 = 0;
                }
            }
             {
                group->inSynInSyn12[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn12[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn12 = 0;
                }
            }
             {
                group->inSynInSyn13[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn13[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn13 = 0;
                }
            }
            // current source variables
        }
    }
    // merged1
    if(id >= 1760 && id < 5440) {
        unsigned int lo = 0;
        unsigned int hi = 3;
        while(lo < hi)
         {
            const unsigned int mid = (lo + hi) / 2;
            if(id < d_mergedNeuronInitGroupStartID1[mid]) {
                hi = mid;
            }
            else {
                lo = mid + 1;
            }
        }
        struct MergedNeuronInitGroup1 *group = &d_mergedNeuronInitGroup1[lo - 1]; 
        const unsigned int groupStartID = d_mergedNeuronInitGroupStartID1[lo - 1];
        const unsigned int lid = id - groupStartID;
        // only do this for existing neurons
        if(lid < group->numNeurons) {
            curandStatePhilox4_32_10_t localRNG = d_rng;
            skipahead_sequence((unsigned long long)id, &localRNG);
            if(lid == 0) {
                group->spkCnt[0] = 0;
            }
            group->spk[lid] = 0;
             {
                scalar initVal;
                initVal = (-1.50000000000000000e+02f) + (curand_normal(&localRNG) * (5.00000000000000000e+01f));
                group->V[lid] = initVal;
            }
             {
                scalar initVal;
                initVal = (0.00000000000000000e+00f);
                group->RefracTime[lid] = initVal;
            }
             {
                group->inSynInSyn0[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn0[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn0 = 0;
                }
            }
             {
                group->inSynInSyn1[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn1[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn1 = 0;
                }
            }
             {
                group->inSynInSyn2[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn2[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn2 = 0;
                }
            }
             {
                group->inSynInSyn3[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn3[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn3 = 0;
                }
            }
             {
                group->inSynInSyn4[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn4[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn4 = 0;
                }
            }
             {
                group->inSynInSyn5[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn5[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn5 = 0;
                }
            }
             {
                group->inSynInSyn6[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn6[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn6 = 0;
                }
            }
             {
                group->inSynInSyn7[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn7[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn7 = 0;
                }
            }
            // current source variables
        }
    }
    // merged2
    if(id >= 5440 && id < 20992) {
        struct MergedNeuronInitGroup2 *group = &d_mergedNeuronInitGroup2[0]; 
        const unsigned int lid = id - 5440;
        // only do this for existing neurons
        if(lid < group->numNeurons) {
            curandStatePhilox4_32_10_t localRNG = d_rng;
            skipahead_sequence((unsigned long long)id, &localRNG);
            if(lid == 0) {
                group->spkCnt[0] = 0;
            }
            group->spk[lid] = 0;
             {
                scalar initVal;
                initVal = (-1.50000000000000000e+02f) + (curand_normal(&localRNG) * (5.00000000000000000e+01f));
                group->V[lid] = initVal;
            }
             {
                scalar initVal;
                initVal = (0.00000000000000000e+00f);
                group->RefracTime[lid] = initVal;
            }
             {
                group->inSynInSyn0[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn0[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn0 = 0;
                }
            }
             {
                group->inSynInSyn1[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn1[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn1 = 0;
                }
            }
             {
                group->inSynInSyn2[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn2[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn2 = 0;
                }
            }
             {
                group->inSynInSyn3[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn3[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn3 = 0;
                }
            }
             {
                group->inSynInSyn4[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn4[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn4 = 0;
                }
            }
             {
                group->inSynInSyn5[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn5[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn5 = 0;
                }
            }
            // current source variables
        }
    }
    // merged3
    if(id >= 20992 && id < 42624) {
        struct MergedNeuronInitGroup3 *group = &d_mergedNeuronInitGroup3[0]; 
        const unsigned int lid = id - 20992;
        // only do this for existing neurons
        if(lid < group->numNeurons) {
            curandStatePhilox4_32_10_t localRNG = d_rng;
            skipahead_sequence((unsigned long long)id, &localRNG);
            if(lid == 0) {
                group->spkCnt[0] = 0;
            }
            group->spk[lid] = 0;
             {
                scalar initVal;
                initVal = (-1.50000000000000000e+02f) + (curand_normal(&localRNG) * (5.00000000000000000e+01f));
                group->V[lid] = initVal;
            }
             {
                scalar initVal;
                initVal = (0.00000000000000000e+00f);
                group->RefracTime[lid] = initVal;
            }
             {
                group->inSynInSyn0[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn0[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn0 = 0;
                }
            }
             {
                group->inSynInSyn1[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn1[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn1 = 0;
                }
            }
             {
                group->inSynInSyn2[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn2[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn2 = 0;
                }
            }
             {
                group->inSynInSyn3[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn3[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn3 = 0;
                }
            }
             {
                group->inSynInSyn4[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn4[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn4 = 0;
                }
            }
             {
                group->inSynInSyn5[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn5[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn5 = 0;
                }
            }
             {
                group->inSynInSyn6[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn6[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn6 = 0;
                }
            }
             {
                group->inSynInSyn7[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn7[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn7 = 0;
                }
            }
             {
                group->inSynInSyn8[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn8[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn8 = 0;
                }
            }
             {
                group->inSynInSyn9[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn9[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn9 = 0;
                }
            }
             {
                group->inSynInSyn10[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn10[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn10 = 0;
                }
            }
             {
                group->inSynInSyn11[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn11[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn11 = 0;
                }
            }
             {
                group->inSynInSyn12[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn12[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn12 = 0;
                }
            }
             {
                group->inSynInSyn13[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn13[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn13 = 0;
                }
            }
             {
                group->inSynInSyn14[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn14[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn14 = 0;
                }
            }
            // current source variables
        }
    }
    // merged4
    if(id >= 42624 && id < 117568) {
        struct MergedNeuronInitGroup4 *group = &d_mergedNeuronInitGroup4[0]; 
        const unsigned int lid = id - 42624;
        // only do this for existing neurons
        if(lid < group->numNeurons) {
            curandStatePhilox4_32_10_t localRNG = d_rng;
            skipahead_sequence((unsigned long long)id, &localRNG);
            if(lid == 0) {
                group->spkCnt[0] = 0;
            }
            group->spk[lid] = 0;
             {
                scalar initVal;
                initVal = (-1.50000000000000000e+02f) + (curand_normal(&localRNG) * (5.00000000000000000e+01f));
                group->V[lid] = initVal;
            }
             {
                scalar initVal;
                initVal = (0.00000000000000000e+00f);
                group->RefracTime[lid] = initVal;
            }
             {
                group->inSynInSyn0[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn0[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn0 = 0;
                }
            }
             {
                group->inSynInSyn1[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn1[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn1 = 0;
                }
            }
             {
                group->inSynInSyn2[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn2[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn2 = 0;
                }
            }
             {
                group->inSynInSyn3[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn3[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn3 = 0;
                }
            }
             {
                group->inSynInSyn4[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn4[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn4 = 0;
                }
            }
             {
                group->inSynInSyn5[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn5[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn5 = 0;
                }
            }
             {
                group->inSynInSyn6[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn6[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn6 = 0;
                }
            }
             {
                group->inSynInSyn7[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn7[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn7 = 0;
                }
            }
             {
                group->inSynInSyn8[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn8[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn8 = 0;
                }
            }
             {
                group->inSynInSyn9[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn9[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn9 = 0;
                }
            }
             {
                group->inSynInSyn10[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn10[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn10 = 0;
                }
            }
             {
                group->inSynInSyn11[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn11[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn11 = 0;
                }
            }
             {
                group->inSynInSyn12[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn12[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn12 = 0;
                }
            }
            // current source variables
        }
    }
    // merged5
    if(id >= 117568 && id < 122112) {
        unsigned int lo = 0;
        unsigned int hi = 2;
        while(lo < hi)
         {
            const unsigned int mid = (lo + hi) / 2;
            if(id < d_mergedNeuronInitGroupStartID5[mid]) {
                hi = mid;
            }
            else {
                lo = mid + 1;
            }
        }
        struct MergedNeuronInitGroup5 *group = &d_mergedNeuronInitGroup5[lo - 1]; 
        const unsigned int groupStartID = d_mergedNeuronInitGroupStartID5[lo - 1];
        const unsigned int lid = id - groupStartID;
        // only do this for existing neurons
        if(lid < group->numNeurons) {
            curandStatePhilox4_32_10_t localRNG = d_rng;
            skipahead_sequence((unsigned long long)id, &localRNG);
            if(lid == 0) {
                group->spkCnt[0] = 0;
            }
            group->spk[lid] = 0;
             {
                scalar initVal;
                initVal = (-1.50000000000000000e+02f) + (curand_normal(&localRNG) * (5.00000000000000000e+01f));
                group->V[lid] = initVal;
            }
             {
                scalar initVal;
                initVal = (0.00000000000000000e+00f);
                group->RefracTime[lid] = initVal;
            }
             {
                group->inSynInSyn0[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn0[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn0 = 0;
                }
            }
             {
                group->inSynInSyn1[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn1[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn1 = 0;
                }
            }
             {
                group->inSynInSyn2[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn2[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn2 = 0;
                }
            }
             {
                group->inSynInSyn3[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn3[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn3 = 0;
                }
            }
             {
                group->inSynInSyn4[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn4[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn4 = 0;
                }
            }
             {
                group->inSynInSyn5[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn5[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn5 = 0;
                }
            }
             {
                group->inSynInSyn6[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn6[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn6 = 0;
                }
            }
             {
                group->inSynInSyn7[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn7[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn7 = 0;
                }
            }
             {
                group->inSynInSyn8[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn8[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn8 = 0;
                }
            }
             {
                group->inSynInSyn9[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn9[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn9 = 0;
                }
            }
             {
                group->inSynInSyn10[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn10[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn10 = 0;
                }
            }
            // current source variables
        }
    }
    // merged6
    if(id >= 122112 && id < 146944) {
        unsigned int lo = 0;
        unsigned int hi = 2;
        while(lo < hi)
         {
            const unsigned int mid = (lo + hi) / 2;
            if(id < d_mergedNeuronInitGroupStartID6[mid]) {
                hi = mid;
            }
            else {
                lo = mid + 1;
            }
        }
        struct MergedNeuronInitGroup6 *group = &d_mergedNeuronInitGroup6[lo - 1]; 
        const unsigned int groupStartID = d_mergedNeuronInitGroupStartID6[lo - 1];
        const unsigned int lid = id - groupStartID;
        // only do this for existing neurons
        if(lid < group->numNeurons) {
            curandStatePhilox4_32_10_t localRNG = d_rng;
            skipahead_sequence((unsigned long long)id, &localRNG);
            if(lid == 0) {
                group->spkCnt[0] = 0;
            }
            group->spk[lid] = 0;
             {
                scalar initVal;
                initVal = (-1.50000000000000000e+02f) + (curand_normal(&localRNG) * (5.00000000000000000e+01f));
                group->V[lid] = initVal;
            }
             {
                scalar initVal;
                initVal = (0.00000000000000000e+00f);
                group->RefracTime[lid] = initVal;
            }
             {
                group->inSynInSyn0[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn0[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn0 = 0;
                }
            }
             {
                group->inSynInSyn1[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn1[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn1 = 0;
                }
            }
             {
                group->inSynInSyn2[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn2[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn2 = 0;
                }
            }
             {
                group->inSynInSyn3[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn3[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn3 = 0;
                }
            }
             {
                group->inSynInSyn4[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn4[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn4 = 0;
                }
            }
             {
                group->inSynInSyn5[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn5[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn5 = 0;
                }
            }
             {
                group->inSynInSyn6[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn6[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn6 = 0;
                }
            }
             {
                group->inSynInSyn7[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn7[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn7 = 0;
                }
            }
             {
                group->inSynInSyn8[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn8[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn8 = 0;
                }
            }
             {
                group->inSynInSyn9[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn9[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn9 = 0;
                }
            }
            // current source variables
        }
    }
    // merged7
    if(id >= 146944 && id < 213728) {
        unsigned int lo = 0;
        unsigned int hi = 6;
        while(lo < hi)
         {
            const unsigned int mid = (lo + hi) / 2;
            if(id < d_mergedNeuronInitGroupStartID7[mid]) {
                hi = mid;
            }
            else {
                lo = mid + 1;
            }
        }
        struct MergedNeuronInitGroup7 *group = &d_mergedNeuronInitGroup7[lo - 1]; 
        const unsigned int groupStartID = d_mergedNeuronInitGroupStartID7[lo - 1];
        const unsigned int lid = id - groupStartID;
        // only do this for existing neurons
        if(lid < group->numNeurons) {
            curandStatePhilox4_32_10_t localRNG = d_rng;
            skipahead_sequence((unsigned long long)id, &localRNG);
            if(lid == 0) {
                group->spkCnt[0] = 0;
            }
            group->spk[lid] = 0;
             {
                scalar initVal;
                initVal = (-1.50000000000000000e+02f) + (curand_normal(&localRNG) * (5.00000000000000000e+01f));
                group->V[lid] = initVal;
            }
             {
                scalar initVal;
                initVal = (0.00000000000000000e+00f);
                group->RefracTime[lid] = initVal;
            }
             {
                group->inSynInSyn0[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn0[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn0 = 0;
                }
            }
             {
                group->inSynInSyn1[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn1[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn1 = 0;
                }
            }
             {
                group->inSynInSyn2[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn2[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn2 = 0;
                }
            }
             {
                group->inSynInSyn3[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn3[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn3 = 0;
                }
            }
             {
                group->inSynInSyn4[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn4[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn4 = 0;
                }
            }
             {
                group->inSynInSyn5[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn5[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn5 = 0;
                }
            }
             {
                group->inSynInSyn6[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn6[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn6 = 0;
                }
            }
             {
                group->inSynInSyn7[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn7[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn7 = 0;
                }
            }
             {
                group->inSynInSyn8[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn8[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn8 = 0;
                }
            }
             {
                group->inSynInSyn9[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn9[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn9 = 0;
                }
            }
             {
                group->inSynInSyn10[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn10[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn10 = 0;
                }
            }
             {
                group->inSynInSyn11[lid] = 0.000000000e+00f;
                for(unsigned int d = 0; d < 43; d++) {
                    group->denDelayInSyn11[(d * group->numNeurons) + lid] = 0.000000000e+00f;
                }
                if(lid == 0) {
                    *group->denDelayPtrInSyn11 = 0;
                }
            }
            // current source variables
        }
    }
    
    // ------------------------------------------------------------------------
    // Synapse groups
    
    // ------------------------------------------------------------------------
    // Custom update groups
    
    // ------------------------------------------------------------------------
    // Custom WU update groups
    
    // ------------------------------------------------------------------------
    // Synapse groups with sparse connectivity
    // merged0
    if(id >= 213728 && id < 2733248) {
        unsigned int lo = 0;
        unsigned int hi = 186;
        while(lo < hi)
         {
            const unsigned int mid = (lo + hi) / 2;
            if(id < d_mergedSynapseConnectivityInitGroupStartID0[mid]) {
                hi = mid;
            }
            else {
                lo = mid + 1;
            }
        }
        struct MergedSynapseConnectivityInitGroup0 *group = &d_mergedSynapseConnectivityInitGroup0[lo - 1]; 
        const unsigned int groupStartID = d_mergedSynapseConnectivityInitGroupStartID0[lo - 1];
        const unsigned int lid = id - groupStartID;
        // only do this for existing presynaptic neurons
        if(lid < group->numSrcNeurons) {
            group->rowLength[lid] = 0;
            curandStatePhilox4_32_10_t localRNG = d_rng;
            skipahead_sequence((unsigned long long)id, &localRNG);
            // Build sparse connectivity
            scalar x = 0.00000000000000000e+00f;
            unsigned int c = group->preCalcRowLength[(lid * 1) + 0];
            while(true) {
                if(c == 0) {
                   break;
                }
                const scalar u = curand_uniform(&localRNG);
                x += (1.0f - x) * (1.0f - pow(u, 1.0f / (scalar)c));
                unsigned int postIdx = (unsigned int)(x * group->numTrgNeurons);
                postIdx = (postIdx < group->numTrgNeurons) ? postIdx : (group->numTrgNeurons - 1);
                do {
                    const unsigned int idx = (lid * group->rowStride) + group->rowLength[lid];
                    group->ind[idx] = postIdx+0;
                    group->rowLength[lid]++;
                }
                while(false);
                c--;
                
            }
        }
    }
    
}
extern "C" __global__ void initializeSparseKernel() {
    const unsigned int id = 64 * blockIdx.x + threadIdx.x;
    __shared__ unsigned int shRowLength[64];
    // merged0
    if(id < 57920) {
        unsigned int lo = 0;
        unsigned int hi = 186;
        while(lo < hi)
         {
            const unsigned int mid = (lo + hi) / 2;
            if(id < d_mergedSynapseSparseInitGroupStartID0[mid]) {
                hi = mid;
            }
            else {
                lo = mid + 1;
            }
        }
        struct MergedSynapseSparseInitGroup0 *group = &d_mergedSynapseSparseInitGroup0[lo - 1]; 
        const unsigned int groupStartID = d_mergedSynapseSparseInitGroupStartID0[lo - 1];
        const unsigned int lid = id - groupStartID;
        curandStatePhilox4_32_10_t localRNG = d_rng;
        skipahead_sequence((unsigned long long)2733248 + id, &localRNG);
        const unsigned int numBlocks = (group->numSrcNeurons + 64 - 1) / 64;
        unsigned int idx = lid;
        for(unsigned int r = 0; r < numBlocks; r++) {
            const unsigned numRowsInBlock = (r == (numBlocks - 1)) ? ((group->numSrcNeurons - 1) % 64) + 1 : 64;
            __syncthreads();
            if (threadIdx.x < numRowsInBlock) {
                shRowLength[threadIdx.x] = group->rowLength[(r * 64) + threadIdx.x];
            }
            __syncthreads();
            for(unsigned int i = 0; i < numRowsInBlock; i++) {
                if(lid < shRowLength[i]) {
                     {
                        scalar initVal;
                        scalar normal;
                        do
                        {
                           normal = group->meang + (curand_normal(&localRNG) * group->sdg);
                        } while (normal > group->maxg || normal < group->ming);
                        initVal = normal;
                        
                        group->g[(((r * 64) + i) * group->rowStride) + lid] = initVal;
                    }
                     {
                        uint8_t initVal;
                        scalar normal;
                        do
                        {
                           normal = group->meanTimestepd + (curand_normal(&localRNG) * group->sdTimestepd);
                        } while (normal > group->maxTimestepd || normal < (0.00000000000000000e+00f));
                        initVal = rint(normal);
                        
                        group->d[(((r * 64) + i) * group->rowStride) + lid] = initVal;
                    }
                }
                idx += group->rowStride;
            }
        }
    }
}
void initialize() {
    unsigned long long deviceRNGSeed = 0;
    deviceRNGSeed = 3186695951;
    initializeRNGKernel<<<1, 1>>>(deviceRNGSeed);
    CHECK_CUDA_ERRORS(cudaPeekAtLastError());
     {
        CHECK_CUDA_ERRORS(cudaEventRecord(initStart));
        const dim3 threads(32, 1);
        const dim3 grid(85414, 1);
        initializeKernel<<<grid, threads>>>(deviceRNGSeed);
        CHECK_CUDA_ERRORS(cudaPeekAtLastError());
        CHECK_CUDA_ERRORS(cudaEventRecord(initStop));
        CHECK_CUDA_ERRORS(cudaEventSynchronize(initStop));
        float tmp;
        CHECK_CUDA_ERRORS(cudaEventElapsedTime(&tmp, initStart, initStop));
        initTime += tmp / 1000.0;
    }
}

void initializeSparse() {
    copyStateToDevice(true);
    copyConnectivityToDevice(true);
    
     {
        CHECK_CUDA_ERRORS(cudaEventRecord(initSparseStart));
        const dim3 threads(64, 1);
        const dim3 grid(905, 1);
        initializeSparseKernel<<<grid, threads>>>();
        CHECK_CUDA_ERRORS(cudaPeekAtLastError());
        CHECK_CUDA_ERRORS(cudaEventRecord(initSparseStop));
        CHECK_CUDA_ERRORS(cudaEventSynchronize(initSparseStop));
        float tmp;
        CHECK_CUDA_ERRORS(cudaEventElapsedTime(&tmp, initSparseStart, initSparseStop));
        initSparseTime += tmp / 1000.0;
    }
}
