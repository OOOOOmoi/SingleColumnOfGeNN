#include "definitionsInternal.h"
#include "supportCode.h"

struct MergedNeuronUpdateGroup0
 {
    float* denDelayInSyn5;
    unsigned int* denDelayPtrInSyn2;
    float* inSynInSyn3;
    float* denDelayInSyn3;
    unsigned int* denDelayPtrInSyn3;
    float* inSynInSyn4;
    float* denDelayInSyn4;
    unsigned int* denDelayPtrInSyn4;
    float* inSynInSyn5;
    float* denDelayInSyn2;
    unsigned int* denDelayPtrInSyn5;
    float* inSynInSyn6;
    float* denDelayInSyn6;
    unsigned int* denDelayPtrInSyn6;
    float* inSynInSyn7;
    float* denDelayInSyn7;
    unsigned int* denDelayPtrInSyn7;
    uint32_t* recordSpk;
    float* inSynInSyn2;
    unsigned int* spkCnt;
    unsigned int* spk;
    scalar* V;
    scalar* RefracTime;
    float* inSynInSyn0;
    float* denDelayInSyn0;
    unsigned int* denDelayPtrInSyn0;
    float* inSynInSyn1;
    float* denDelayInSyn1;
    unsigned int* denDelayPtrInSyn1;
    scalar Rmembrane;
    scalar ExpTC;
    scalar Vreset;
    scalar Vrest;
    scalar TauM;
    scalar C;
    unsigned int numNeurons;
    
}
;
struct MergedNeuronUpdateGroup1
 {
    float* denDelayInSyn10;
    unsigned int* denDelayPtrInSyn6;
    float* inSynInSyn7;
    float* denDelayInSyn7;
    unsigned int* denDelayPtrInSyn7;
    float* inSynInSyn8;
    float* denDelayInSyn8;
    unsigned int* denDelayPtrInSyn8;
    float* inSynInSyn9;
    float* denDelayInSyn9;
    unsigned int* denDelayPtrInSyn9;
    float* inSynInSyn10;
    float* denDelayInSyn6;
    unsigned int* denDelayPtrInSyn10;
    float* inSynInSyn11;
    float* denDelayInSyn11;
    unsigned int* denDelayPtrInSyn11;
    float* inSynInSyn12;
    float* denDelayInSyn12;
    unsigned int* denDelayPtrInSyn12;
    float* inSynInSyn13;
    float* denDelayInSyn13;
    unsigned int* denDelayPtrInSyn13;
    uint32_t* recordSpk;
    float* denDelayInSyn2;
    unsigned int* spkCnt;
    unsigned int* spk;
    scalar* V;
    scalar* RefracTime;
    float* inSynInSyn0;
    float* denDelayInSyn0;
    unsigned int* denDelayPtrInSyn0;
    float* inSynInSyn1;
    float* denDelayInSyn1;
    unsigned int* denDelayPtrInSyn1;
    float* inSynInSyn2;
    unsigned int* denDelayPtrInSyn2;
    float* inSynInSyn3;
    float* denDelayInSyn3;
    unsigned int* denDelayPtrInSyn3;
    float* inSynInSyn4;
    float* denDelayInSyn4;
    unsigned int* denDelayPtrInSyn4;
    float* inSynInSyn5;
    float* denDelayInSyn5;
    unsigned int* denDelayPtrInSyn5;
    float* inSynInSyn6;
    unsigned int numNeurons;
    
}
;
struct MergedNeuronUpdateGroup2
 {
    float* denDelayInSyn2;
    uint32_t* recordSpk;
    unsigned int* denDelayPtrInSyn5;
    float* denDelayInSyn5;
    float* inSynInSyn5;
    unsigned int* denDelayPtrInSyn4;
    float* denDelayInSyn4;
    float* inSynInSyn4;
    unsigned int* denDelayPtrInSyn3;
    float* denDelayInSyn3;
    float* inSynInSyn3;
    unsigned int* denDelayPtrInSyn2;
    float* inSynInSyn2;
    unsigned int* denDelayPtrInSyn1;
    float* denDelayInSyn1;
    float* inSynInSyn1;
    unsigned int* denDelayPtrInSyn0;
    float* denDelayInSyn0;
    float* inSynInSyn0;
    scalar* RefracTime;
    scalar* V;
    unsigned int* spk;
    unsigned int* spkCnt;
    unsigned int numNeurons;
    
}
;
struct MergedNeuronUpdateGroup3
 {
    unsigned int* denDelayPtrInSyn7;
    float* inSynInSyn4;
    float* denDelayInSyn4;
    unsigned int* denDelayPtrInSyn4;
    float* inSynInSyn5;
    float* denDelayInSyn5;
    unsigned int* denDelayPtrInSyn5;
    float* inSynInSyn6;
    float* denDelayInSyn6;
    unsigned int* denDelayPtrInSyn6;
    float* inSynInSyn7;
    float* denDelayInSyn7;
    unsigned int* denDelayPtrInSyn3;
    float* inSynInSyn8;
    float* denDelayInSyn8;
    unsigned int* denDelayPtrInSyn8;
    float* inSynInSyn9;
    float* denDelayInSyn9;
    unsigned int* denDelayPtrInSyn9;
    float* inSynInSyn10;
    float* denDelayInSyn10;
    unsigned int* denDelayPtrInSyn10;
    uint32_t* recordSpk;
    float* inSynInSyn0;
    unsigned int* spkCnt;
    unsigned int* spk;
    scalar* V;
    scalar* RefracTime;
    float* denDelayInSyn0;
    unsigned int* denDelayPtrInSyn0;
    float* inSynInSyn1;
    float* denDelayInSyn1;
    unsigned int* denDelayPtrInSyn1;
    float* inSynInSyn2;
    float* denDelayInSyn2;
    unsigned int* denDelayPtrInSyn2;
    float* inSynInSyn3;
    float* denDelayInSyn3;
    unsigned int numNeurons;
    scalar Rmembrane;
    scalar ExpTC;
    scalar Ioffset;
    scalar Vrest;
    scalar TauM;
    scalar C;
    
}
;
struct MergedNeuronUpdateGroup4
 {
    float* inSynInSyn7;
    unsigned int* denDelayPtrInSyn3;
    float* inSynInSyn4;
    float* denDelayInSyn4;
    unsigned int* denDelayPtrInSyn4;
    float* inSynInSyn5;
    float* denDelayInSyn5;
    unsigned int* denDelayPtrInSyn5;
    float* inSynInSyn6;
    float* denDelayInSyn6;
    unsigned int* denDelayPtrInSyn6;
    float* denDelayInSyn3;
    float* denDelayInSyn7;
    unsigned int* denDelayPtrInSyn7;
    float* inSynInSyn8;
    float* denDelayInSyn8;
    unsigned int* denDelayPtrInSyn8;
    float* inSynInSyn9;
    float* denDelayInSyn9;
    unsigned int* denDelayPtrInSyn9;
    uint32_t* recordSpk;
    float* inSynInSyn0;
    unsigned int* spkCnt;
    unsigned int* spk;
    scalar* V;
    scalar* RefracTime;
    float* denDelayInSyn0;
    unsigned int* denDelayPtrInSyn0;
    float* inSynInSyn1;
    float* denDelayInSyn1;
    unsigned int* denDelayPtrInSyn1;
    float* inSynInSyn2;
    float* denDelayInSyn2;
    unsigned int* denDelayPtrInSyn2;
    float* inSynInSyn3;
    unsigned int numNeurons;
    scalar Rmembrane;
    scalar TauRefrac;
    scalar Ioffset;
    scalar Vreset;
    scalar C;
    
}
;
struct MergedNeuronUpdateGroup5
 {
    float* inSynInSyn11;
    float* inSynInSyn7;
    float* denDelayInSyn7;
    unsigned int* denDelayPtrInSyn7;
    float* inSynInSyn8;
    float* denDelayInSyn8;
    unsigned int* denDelayPtrInSyn8;
    float* inSynInSyn9;
    float* denDelayInSyn9;
    unsigned int* denDelayPtrInSyn9;
    float* inSynInSyn10;
    float* denDelayInSyn10;
    unsigned int* denDelayPtrInSyn10;
    unsigned int* denDelayPtrInSyn6;
    float* denDelayInSyn11;
    unsigned int* denDelayPtrInSyn11;
    float* inSynInSyn12;
    float* denDelayInSyn12;
    unsigned int* denDelayPtrInSyn12;
    float* inSynInSyn13;
    float* denDelayInSyn13;
    unsigned int* denDelayPtrInSyn13;
    float* inSynInSyn14;
    float* denDelayInSyn14;
    unsigned int* denDelayPtrInSyn14;
    uint32_t* recordSpk;
    unsigned int* denDelayPtrInSyn2;
    unsigned int* spkCnt;
    unsigned int* spk;
    scalar* V;
    scalar* RefracTime;
    float* inSynInSyn0;
    float* denDelayInSyn0;
    unsigned int* denDelayPtrInSyn0;
    float* inSynInSyn1;
    float* denDelayInSyn1;
    unsigned int* denDelayPtrInSyn1;
    float* inSynInSyn2;
    float* denDelayInSyn2;
    float* inSynInSyn3;
    float* denDelayInSyn3;
    unsigned int* denDelayPtrInSyn3;
    float* inSynInSyn4;
    float* denDelayInSyn4;
    unsigned int* denDelayPtrInSyn4;
    float* inSynInSyn5;
    float* denDelayInSyn5;
    unsigned int* denDelayPtrInSyn5;
    float* inSynInSyn6;
    float* denDelayInSyn6;
    unsigned int numNeurons;
    
}
;
struct MergedNeuronUpdateGroup6
 {
    unsigned int* denDelayPtrInSyn9;
    float* inSynInSyn6;
    float* denDelayInSyn6;
    unsigned int* denDelayPtrInSyn6;
    float* inSynInSyn7;
    float* denDelayInSyn7;
    unsigned int* denDelayPtrInSyn7;
    float* inSynInSyn8;
    float* denDelayInSyn8;
    unsigned int* denDelayPtrInSyn8;
    float* inSynInSyn9;
    float* denDelayInSyn9;
    unsigned int* denDelayPtrInSyn5;
    float* inSynInSyn10;
    float* denDelayInSyn10;
    unsigned int* denDelayPtrInSyn10;
    float* inSynInSyn11;
    float* denDelayInSyn11;
    unsigned int* denDelayPtrInSyn11;
    float* inSynInSyn12;
    float* denDelayInSyn12;
    unsigned int* denDelayPtrInSyn12;
    uint32_t* recordSpk;
    float* inSynInSyn2;
    unsigned int* spkCnt;
    unsigned int* spk;
    scalar* V;
    scalar* RefracTime;
    float* inSynInSyn0;
    float* denDelayInSyn0;
    unsigned int* denDelayPtrInSyn0;
    float* inSynInSyn1;
    float* denDelayInSyn1;
    unsigned int* denDelayPtrInSyn1;
    float* denDelayInSyn2;
    unsigned int* denDelayPtrInSyn2;
    float* inSynInSyn3;
    float* denDelayInSyn3;
    unsigned int* denDelayPtrInSyn3;
    float* inSynInSyn4;
    float* denDelayInSyn4;
    unsigned int* denDelayPtrInSyn4;
    float* inSynInSyn5;
    float* denDelayInSyn5;
    unsigned int numNeurons;
    
}
;
struct MergedNeuronUpdateGroup7
 {
    float* denDelayInSyn8;
    float* denDelayInSyn4;
    unsigned int* denDelayPtrInSyn4;
    float* inSynInSyn5;
    float* denDelayInSyn5;
    unsigned int* denDelayPtrInSyn5;
    float* inSynInSyn6;
    float* denDelayInSyn6;
    unsigned int* denDelayPtrInSyn6;
    float* inSynInSyn7;
    float* denDelayInSyn7;
    unsigned int* denDelayPtrInSyn7;
    float* inSynInSyn8;
    float* inSynInSyn4;
    unsigned int* denDelayPtrInSyn8;
    float* inSynInSyn9;
    float* denDelayInSyn9;
    unsigned int* denDelayPtrInSyn9;
    float* inSynInSyn10;
    float* denDelayInSyn10;
    unsigned int* denDelayPtrInSyn10;
    float* inSynInSyn11;
    float* denDelayInSyn11;
    unsigned int* denDelayPtrInSyn11;
    uint32_t* recordSpk;
    float* inSynInSyn0;
    unsigned int* spkCnt;
    unsigned int* spk;
    scalar* V;
    scalar* RefracTime;
    float* denDelayInSyn0;
    unsigned int* denDelayPtrInSyn0;
    float* inSynInSyn1;
    unsigned int* denDelayPtrInSyn1;
    unsigned int* denDelayPtrInSyn3;
    float* denDelayInSyn3;
    float* inSynInSyn3;
    unsigned int* denDelayPtrInSyn2;
    float* denDelayInSyn2;
    float* inSynInSyn2;
    float* denDelayInSyn1;
    scalar Rmembrane;
    scalar ExpTC;
    scalar TauRefrac;
    scalar Ioffset;
    scalar Vreset;
    scalar Vrest;
    scalar TauM;
    scalar C;
    unsigned int numNeurons;
    
}
;
struct MergedNeuronSpikeQueueUpdateGroup0
 {
    unsigned int* spkCnt;
    
}
;
__device__ __constant__ MergedNeuronSpikeQueueUpdateGroup0 d_mergedNeuronSpikeQueueUpdateGroup0[17];
void pushMergedNeuronSpikeQueueUpdateGroup0ToDevice(unsigned int idx, unsigned int* spkCnt) {
    MergedNeuronSpikeQueueUpdateGroup0 group = {spkCnt, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronSpikeQueueUpdateGroup0, &group, sizeof(MergedNeuronSpikeQueueUpdateGroup0), idx * sizeof(MergedNeuronSpikeQueueUpdateGroup0)));
}
__device__ __constant__ MergedNeuronUpdateGroup0 d_mergedNeuronUpdateGroup0[3];
void pushMergedNeuronUpdateGroup0ToDevice(unsigned int idx, float* denDelayInSyn5, unsigned int* denDelayPtrInSyn2, float* inSynInSyn3, float* denDelayInSyn3, unsigned int* denDelayPtrInSyn3, float* inSynInSyn4, float* denDelayInSyn4, unsigned int* denDelayPtrInSyn4, float* inSynInSyn5, float* denDelayInSyn2, unsigned int* denDelayPtrInSyn5, float* inSynInSyn6, float* denDelayInSyn6, unsigned int* denDelayPtrInSyn6, float* inSynInSyn7, float* denDelayInSyn7, unsigned int* denDelayPtrInSyn7, uint32_t* recordSpk, float* inSynInSyn2, unsigned int* spkCnt, unsigned int* spk, scalar* V, scalar* RefracTime, float* inSynInSyn0, float* denDelayInSyn0, unsigned int* denDelayPtrInSyn0, float* inSynInSyn1, float* denDelayInSyn1, unsigned int* denDelayPtrInSyn1, scalar Rmembrane, scalar ExpTC, scalar Vreset, scalar Vrest, scalar TauM, scalar C, unsigned int numNeurons) {
    MergedNeuronUpdateGroup0 group = {denDelayInSyn5, denDelayPtrInSyn2, inSynInSyn3, denDelayInSyn3, denDelayPtrInSyn3, inSynInSyn4, denDelayInSyn4, denDelayPtrInSyn4, inSynInSyn5, denDelayInSyn2, denDelayPtrInSyn5, inSynInSyn6, denDelayInSyn6, denDelayPtrInSyn6, inSynInSyn7, denDelayInSyn7, denDelayPtrInSyn7, recordSpk, inSynInSyn2, spkCnt, spk, V, RefracTime, inSynInSyn0, denDelayInSyn0, denDelayPtrInSyn0, inSynInSyn1, denDelayInSyn1, denDelayPtrInSyn1, Rmembrane, ExpTC, Vreset, Vrest, TauM, C, numNeurons, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronUpdateGroup0, &group, sizeof(MergedNeuronUpdateGroup0), idx * sizeof(MergedNeuronUpdateGroup0)));
}
__device__ __constant__ MergedNeuronUpdateGroup1 d_mergedNeuronUpdateGroup1[1];
void pushMergedNeuronUpdateGroup1ToDevice(unsigned int idx, float* denDelayInSyn10, unsigned int* denDelayPtrInSyn6, float* inSynInSyn7, float* denDelayInSyn7, unsigned int* denDelayPtrInSyn7, float* inSynInSyn8, float* denDelayInSyn8, unsigned int* denDelayPtrInSyn8, float* inSynInSyn9, float* denDelayInSyn9, unsigned int* denDelayPtrInSyn9, float* inSynInSyn10, float* denDelayInSyn6, unsigned int* denDelayPtrInSyn10, float* inSynInSyn11, float* denDelayInSyn11, unsigned int* denDelayPtrInSyn11, float* inSynInSyn12, float* denDelayInSyn12, unsigned int* denDelayPtrInSyn12, float* inSynInSyn13, float* denDelayInSyn13, unsigned int* denDelayPtrInSyn13, uint32_t* recordSpk, float* denDelayInSyn2, unsigned int* spkCnt, unsigned int* spk, scalar* V, scalar* RefracTime, float* inSynInSyn0, float* denDelayInSyn0, unsigned int* denDelayPtrInSyn0, float* inSynInSyn1, float* denDelayInSyn1, unsigned int* denDelayPtrInSyn1, float* inSynInSyn2, unsigned int* denDelayPtrInSyn2, float* inSynInSyn3, float* denDelayInSyn3, unsigned int* denDelayPtrInSyn3, float* inSynInSyn4, float* denDelayInSyn4, unsigned int* denDelayPtrInSyn4, float* inSynInSyn5, float* denDelayInSyn5, unsigned int* denDelayPtrInSyn5, float* inSynInSyn6, unsigned int numNeurons) {
    MergedNeuronUpdateGroup1 group = {denDelayInSyn10, denDelayPtrInSyn6, inSynInSyn7, denDelayInSyn7, denDelayPtrInSyn7, inSynInSyn8, denDelayInSyn8, denDelayPtrInSyn8, inSynInSyn9, denDelayInSyn9, denDelayPtrInSyn9, inSynInSyn10, denDelayInSyn6, denDelayPtrInSyn10, inSynInSyn11, denDelayInSyn11, denDelayPtrInSyn11, inSynInSyn12, denDelayInSyn12, denDelayPtrInSyn12, inSynInSyn13, denDelayInSyn13, denDelayPtrInSyn13, recordSpk, denDelayInSyn2, spkCnt, spk, V, RefracTime, inSynInSyn0, denDelayInSyn0, denDelayPtrInSyn0, inSynInSyn1, denDelayInSyn1, denDelayPtrInSyn1, inSynInSyn2, denDelayPtrInSyn2, inSynInSyn3, denDelayInSyn3, denDelayPtrInSyn3, inSynInSyn4, denDelayInSyn4, denDelayPtrInSyn4, inSynInSyn5, denDelayInSyn5, denDelayPtrInSyn5, inSynInSyn6, numNeurons, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronUpdateGroup1, &group, sizeof(MergedNeuronUpdateGroup1), idx * sizeof(MergedNeuronUpdateGroup1)));
}
__device__ __constant__ MergedNeuronUpdateGroup2 d_mergedNeuronUpdateGroup2[1];
void pushMergedNeuronUpdateGroup2ToDevice(unsigned int idx, float* denDelayInSyn2, uint32_t* recordSpk, unsigned int* denDelayPtrInSyn5, float* denDelayInSyn5, float* inSynInSyn5, unsigned int* denDelayPtrInSyn4, float* denDelayInSyn4, float* inSynInSyn4, unsigned int* denDelayPtrInSyn3, float* denDelayInSyn3, float* inSynInSyn3, unsigned int* denDelayPtrInSyn2, float* inSynInSyn2, unsigned int* denDelayPtrInSyn1, float* denDelayInSyn1, float* inSynInSyn1, unsigned int* denDelayPtrInSyn0, float* denDelayInSyn0, float* inSynInSyn0, scalar* RefracTime, scalar* V, unsigned int* spk, unsigned int* spkCnt, unsigned int numNeurons) {
    MergedNeuronUpdateGroup2 group = {denDelayInSyn2, recordSpk, denDelayPtrInSyn5, denDelayInSyn5, inSynInSyn5, denDelayPtrInSyn4, denDelayInSyn4, inSynInSyn4, denDelayPtrInSyn3, denDelayInSyn3, inSynInSyn3, denDelayPtrInSyn2, inSynInSyn2, denDelayPtrInSyn1, denDelayInSyn1, inSynInSyn1, denDelayPtrInSyn0, denDelayInSyn0, inSynInSyn0, RefracTime, V, spk, spkCnt, numNeurons, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronUpdateGroup2, &group, sizeof(MergedNeuronUpdateGroup2), idx * sizeof(MergedNeuronUpdateGroup2)));
}
__device__ __constant__ MergedNeuronUpdateGroup3 d_mergedNeuronUpdateGroup3[2];
void pushMergedNeuronUpdateGroup3ToDevice(unsigned int idx, unsigned int* denDelayPtrInSyn7, float* inSynInSyn4, float* denDelayInSyn4, unsigned int* denDelayPtrInSyn4, float* inSynInSyn5, float* denDelayInSyn5, unsigned int* denDelayPtrInSyn5, float* inSynInSyn6, float* denDelayInSyn6, unsigned int* denDelayPtrInSyn6, float* inSynInSyn7, float* denDelayInSyn7, unsigned int* denDelayPtrInSyn3, float* inSynInSyn8, float* denDelayInSyn8, unsigned int* denDelayPtrInSyn8, float* inSynInSyn9, float* denDelayInSyn9, unsigned int* denDelayPtrInSyn9, float* inSynInSyn10, float* denDelayInSyn10, unsigned int* denDelayPtrInSyn10, uint32_t* recordSpk, float* inSynInSyn0, unsigned int* spkCnt, unsigned int* spk, scalar* V, scalar* RefracTime, float* denDelayInSyn0, unsigned int* denDelayPtrInSyn0, float* inSynInSyn1, float* denDelayInSyn1, unsigned int* denDelayPtrInSyn1, float* inSynInSyn2, float* denDelayInSyn2, unsigned int* denDelayPtrInSyn2, float* inSynInSyn3, float* denDelayInSyn3, unsigned int numNeurons, scalar Rmembrane, scalar ExpTC, scalar Ioffset, scalar Vrest, scalar TauM, scalar C) {
    MergedNeuronUpdateGroup3 group = {denDelayPtrInSyn7, inSynInSyn4, denDelayInSyn4, denDelayPtrInSyn4, inSynInSyn5, denDelayInSyn5, denDelayPtrInSyn5, inSynInSyn6, denDelayInSyn6, denDelayPtrInSyn6, inSynInSyn7, denDelayInSyn7, denDelayPtrInSyn3, inSynInSyn8, denDelayInSyn8, denDelayPtrInSyn8, inSynInSyn9, denDelayInSyn9, denDelayPtrInSyn9, inSynInSyn10, denDelayInSyn10, denDelayPtrInSyn10, recordSpk, inSynInSyn0, spkCnt, spk, V, RefracTime, denDelayInSyn0, denDelayPtrInSyn0, inSynInSyn1, denDelayInSyn1, denDelayPtrInSyn1, inSynInSyn2, denDelayInSyn2, denDelayPtrInSyn2, inSynInSyn3, denDelayInSyn3, numNeurons, Rmembrane, ExpTC, Ioffset, Vrest, TauM, C, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronUpdateGroup3, &group, sizeof(MergedNeuronUpdateGroup3), idx * sizeof(MergedNeuronUpdateGroup3)));
}
__device__ __constant__ MergedNeuronUpdateGroup4 d_mergedNeuronUpdateGroup4[2];
void pushMergedNeuronUpdateGroup4ToDevice(unsigned int idx, float* inSynInSyn7, unsigned int* denDelayPtrInSyn3, float* inSynInSyn4, float* denDelayInSyn4, unsigned int* denDelayPtrInSyn4, float* inSynInSyn5, float* denDelayInSyn5, unsigned int* denDelayPtrInSyn5, float* inSynInSyn6, float* denDelayInSyn6, unsigned int* denDelayPtrInSyn6, float* denDelayInSyn3, float* denDelayInSyn7, unsigned int* denDelayPtrInSyn7, float* inSynInSyn8, float* denDelayInSyn8, unsigned int* denDelayPtrInSyn8, float* inSynInSyn9, float* denDelayInSyn9, unsigned int* denDelayPtrInSyn9, uint32_t* recordSpk, float* inSynInSyn0, unsigned int* spkCnt, unsigned int* spk, scalar* V, scalar* RefracTime, float* denDelayInSyn0, unsigned int* denDelayPtrInSyn0, float* inSynInSyn1, float* denDelayInSyn1, unsigned int* denDelayPtrInSyn1, float* inSynInSyn2, float* denDelayInSyn2, unsigned int* denDelayPtrInSyn2, float* inSynInSyn3, unsigned int numNeurons, scalar Rmembrane, scalar TauRefrac, scalar Ioffset, scalar Vreset, scalar C) {
    MergedNeuronUpdateGroup4 group = {inSynInSyn7, denDelayPtrInSyn3, inSynInSyn4, denDelayInSyn4, denDelayPtrInSyn4, inSynInSyn5, denDelayInSyn5, denDelayPtrInSyn5, inSynInSyn6, denDelayInSyn6, denDelayPtrInSyn6, denDelayInSyn3, denDelayInSyn7, denDelayPtrInSyn7, inSynInSyn8, denDelayInSyn8, denDelayPtrInSyn8, inSynInSyn9, denDelayInSyn9, denDelayPtrInSyn9, recordSpk, inSynInSyn0, spkCnt, spk, V, RefracTime, denDelayInSyn0, denDelayPtrInSyn0, inSynInSyn1, denDelayInSyn1, denDelayPtrInSyn1, inSynInSyn2, denDelayInSyn2, denDelayPtrInSyn2, inSynInSyn3, numNeurons, Rmembrane, TauRefrac, Ioffset, Vreset, C, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronUpdateGroup4, &group, sizeof(MergedNeuronUpdateGroup4), idx * sizeof(MergedNeuronUpdateGroup4)));
}
__device__ __constant__ MergedNeuronUpdateGroup5 d_mergedNeuronUpdateGroup5[1];
void pushMergedNeuronUpdateGroup5ToDevice(unsigned int idx, float* inSynInSyn11, float* inSynInSyn7, float* denDelayInSyn7, unsigned int* denDelayPtrInSyn7, float* inSynInSyn8, float* denDelayInSyn8, unsigned int* denDelayPtrInSyn8, float* inSynInSyn9, float* denDelayInSyn9, unsigned int* denDelayPtrInSyn9, float* inSynInSyn10, float* denDelayInSyn10, unsigned int* denDelayPtrInSyn10, unsigned int* denDelayPtrInSyn6, float* denDelayInSyn11, unsigned int* denDelayPtrInSyn11, float* inSynInSyn12, float* denDelayInSyn12, unsigned int* denDelayPtrInSyn12, float* inSynInSyn13, float* denDelayInSyn13, unsigned int* denDelayPtrInSyn13, float* inSynInSyn14, float* denDelayInSyn14, unsigned int* denDelayPtrInSyn14, uint32_t* recordSpk, unsigned int* denDelayPtrInSyn2, unsigned int* spkCnt, unsigned int* spk, scalar* V, scalar* RefracTime, float* inSynInSyn0, float* denDelayInSyn0, unsigned int* denDelayPtrInSyn0, float* inSynInSyn1, float* denDelayInSyn1, unsigned int* denDelayPtrInSyn1, float* inSynInSyn2, float* denDelayInSyn2, float* inSynInSyn3, float* denDelayInSyn3, unsigned int* denDelayPtrInSyn3, float* inSynInSyn4, float* denDelayInSyn4, unsigned int* denDelayPtrInSyn4, float* inSynInSyn5, float* denDelayInSyn5, unsigned int* denDelayPtrInSyn5, float* inSynInSyn6, float* denDelayInSyn6, unsigned int numNeurons) {
    MergedNeuronUpdateGroup5 group = {inSynInSyn11, inSynInSyn7, denDelayInSyn7, denDelayPtrInSyn7, inSynInSyn8, denDelayInSyn8, denDelayPtrInSyn8, inSynInSyn9, denDelayInSyn9, denDelayPtrInSyn9, inSynInSyn10, denDelayInSyn10, denDelayPtrInSyn10, denDelayPtrInSyn6, denDelayInSyn11, denDelayPtrInSyn11, inSynInSyn12, denDelayInSyn12, denDelayPtrInSyn12, inSynInSyn13, denDelayInSyn13, denDelayPtrInSyn13, inSynInSyn14, denDelayInSyn14, denDelayPtrInSyn14, recordSpk, denDelayPtrInSyn2, spkCnt, spk, V, RefracTime, inSynInSyn0, denDelayInSyn0, denDelayPtrInSyn0, inSynInSyn1, denDelayInSyn1, denDelayPtrInSyn1, inSynInSyn2, denDelayInSyn2, inSynInSyn3, denDelayInSyn3, denDelayPtrInSyn3, inSynInSyn4, denDelayInSyn4, denDelayPtrInSyn4, inSynInSyn5, denDelayInSyn5, denDelayPtrInSyn5, inSynInSyn6, denDelayInSyn6, numNeurons, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronUpdateGroup5, &group, sizeof(MergedNeuronUpdateGroup5), idx * sizeof(MergedNeuronUpdateGroup5)));
}
__device__ __constant__ MergedNeuronUpdateGroup6 d_mergedNeuronUpdateGroup6[1];
void pushMergedNeuronUpdateGroup6ToDevice(unsigned int idx, unsigned int* denDelayPtrInSyn9, float* inSynInSyn6, float* denDelayInSyn6, unsigned int* denDelayPtrInSyn6, float* inSynInSyn7, float* denDelayInSyn7, unsigned int* denDelayPtrInSyn7, float* inSynInSyn8, float* denDelayInSyn8, unsigned int* denDelayPtrInSyn8, float* inSynInSyn9, float* denDelayInSyn9, unsigned int* denDelayPtrInSyn5, float* inSynInSyn10, float* denDelayInSyn10, unsigned int* denDelayPtrInSyn10, float* inSynInSyn11, float* denDelayInSyn11, unsigned int* denDelayPtrInSyn11, float* inSynInSyn12, float* denDelayInSyn12, unsigned int* denDelayPtrInSyn12, uint32_t* recordSpk, float* inSynInSyn2, unsigned int* spkCnt, unsigned int* spk, scalar* V, scalar* RefracTime, float* inSynInSyn0, float* denDelayInSyn0, unsigned int* denDelayPtrInSyn0, float* inSynInSyn1, float* denDelayInSyn1, unsigned int* denDelayPtrInSyn1, float* denDelayInSyn2, unsigned int* denDelayPtrInSyn2, float* inSynInSyn3, float* denDelayInSyn3, unsigned int* denDelayPtrInSyn3, float* inSynInSyn4, float* denDelayInSyn4, unsigned int* denDelayPtrInSyn4, float* inSynInSyn5, float* denDelayInSyn5, unsigned int numNeurons) {
    MergedNeuronUpdateGroup6 group = {denDelayPtrInSyn9, inSynInSyn6, denDelayInSyn6, denDelayPtrInSyn6, inSynInSyn7, denDelayInSyn7, denDelayPtrInSyn7, inSynInSyn8, denDelayInSyn8, denDelayPtrInSyn8, inSynInSyn9, denDelayInSyn9, denDelayPtrInSyn5, inSynInSyn10, denDelayInSyn10, denDelayPtrInSyn10, inSynInSyn11, denDelayInSyn11, denDelayPtrInSyn11, inSynInSyn12, denDelayInSyn12, denDelayPtrInSyn12, recordSpk, inSynInSyn2, spkCnt, spk, V, RefracTime, inSynInSyn0, denDelayInSyn0, denDelayPtrInSyn0, inSynInSyn1, denDelayInSyn1, denDelayPtrInSyn1, denDelayInSyn2, denDelayPtrInSyn2, inSynInSyn3, denDelayInSyn3, denDelayPtrInSyn3, inSynInSyn4, denDelayInSyn4, denDelayPtrInSyn4, inSynInSyn5, denDelayInSyn5, numNeurons, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronUpdateGroup6, &group, sizeof(MergedNeuronUpdateGroup6), idx * sizeof(MergedNeuronUpdateGroup6)));
}
__device__ __constant__ MergedNeuronUpdateGroup7 d_mergedNeuronUpdateGroup7[6];
void pushMergedNeuronUpdateGroup7ToDevice(unsigned int idx, float* denDelayInSyn8, float* denDelayInSyn4, unsigned int* denDelayPtrInSyn4, float* inSynInSyn5, float* denDelayInSyn5, unsigned int* denDelayPtrInSyn5, float* inSynInSyn6, float* denDelayInSyn6, unsigned int* denDelayPtrInSyn6, float* inSynInSyn7, float* denDelayInSyn7, unsigned int* denDelayPtrInSyn7, float* inSynInSyn8, float* inSynInSyn4, unsigned int* denDelayPtrInSyn8, float* inSynInSyn9, float* denDelayInSyn9, unsigned int* denDelayPtrInSyn9, float* inSynInSyn10, float* denDelayInSyn10, unsigned int* denDelayPtrInSyn10, float* inSynInSyn11, float* denDelayInSyn11, unsigned int* denDelayPtrInSyn11, uint32_t* recordSpk, float* inSynInSyn0, unsigned int* spkCnt, unsigned int* spk, scalar* V, scalar* RefracTime, float* denDelayInSyn0, unsigned int* denDelayPtrInSyn0, float* inSynInSyn1, unsigned int* denDelayPtrInSyn1, unsigned int* denDelayPtrInSyn3, float* denDelayInSyn3, float* inSynInSyn3, unsigned int* denDelayPtrInSyn2, float* denDelayInSyn2, float* inSynInSyn2, float* denDelayInSyn1, scalar Rmembrane, scalar ExpTC, scalar TauRefrac, scalar Ioffset, scalar Vreset, scalar Vrest, scalar TauM, scalar C, unsigned int numNeurons) {
    MergedNeuronUpdateGroup7 group = {denDelayInSyn8, denDelayInSyn4, denDelayPtrInSyn4, inSynInSyn5, denDelayInSyn5, denDelayPtrInSyn5, inSynInSyn6, denDelayInSyn6, denDelayPtrInSyn6, inSynInSyn7, denDelayInSyn7, denDelayPtrInSyn7, inSynInSyn8, inSynInSyn4, denDelayPtrInSyn8, inSynInSyn9, denDelayInSyn9, denDelayPtrInSyn9, inSynInSyn10, denDelayInSyn10, denDelayPtrInSyn10, inSynInSyn11, denDelayInSyn11, denDelayPtrInSyn11, recordSpk, inSynInSyn0, spkCnt, spk, V, RefracTime, denDelayInSyn0, denDelayPtrInSyn0, inSynInSyn1, denDelayPtrInSyn1, denDelayPtrInSyn3, denDelayInSyn3, inSynInSyn3, denDelayPtrInSyn2, denDelayInSyn2, inSynInSyn2, denDelayInSyn1, Rmembrane, ExpTC, TauRefrac, Ioffset, Vreset, Vrest, TauM, C, numNeurons, };
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronUpdateGroup7, &group, sizeof(MergedNeuronUpdateGroup7), idx * sizeof(MergedNeuronUpdateGroup7)));
}
// ------------------------------------------------------------------------
// merged extra global parameter functions
// ------------------------------------------------------------------------
// ------------------------------------------------------------------------
// merged extra global parameter functions
// ------------------------------------------------------------------------
void pushMergedNeuronUpdate0recordSpkToDevice(unsigned int idx, uint32_t* value) {
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronUpdateGroup0, &value, sizeof(value), (sizeof(MergedNeuronUpdateGroup0) * (idx)) + offsetof(MergedNeuronUpdateGroup0, recordSpk)));
}

void pushMergedNeuronUpdate1recordSpkToDevice(unsigned int idx, uint32_t* value) {
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronUpdateGroup1, &value, sizeof(value), (sizeof(MergedNeuronUpdateGroup1) * (idx)) + offsetof(MergedNeuronUpdateGroup1, recordSpk)));
}

void pushMergedNeuronUpdate2recordSpkToDevice(unsigned int idx, uint32_t* value) {
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronUpdateGroup2, &value, sizeof(value), (sizeof(MergedNeuronUpdateGroup2) * (idx)) + offsetof(MergedNeuronUpdateGroup2, recordSpk)));
}

void pushMergedNeuronUpdate3recordSpkToDevice(unsigned int idx, uint32_t* value) {
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronUpdateGroup3, &value, sizeof(value), (sizeof(MergedNeuronUpdateGroup3) * (idx)) + offsetof(MergedNeuronUpdateGroup3, recordSpk)));
}

void pushMergedNeuronUpdate4recordSpkToDevice(unsigned int idx, uint32_t* value) {
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronUpdateGroup4, &value, sizeof(value), (sizeof(MergedNeuronUpdateGroup4) * (idx)) + offsetof(MergedNeuronUpdateGroup4, recordSpk)));
}

void pushMergedNeuronUpdate5recordSpkToDevice(unsigned int idx, uint32_t* value) {
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronUpdateGroup5, &value, sizeof(value), (sizeof(MergedNeuronUpdateGroup5) * (idx)) + offsetof(MergedNeuronUpdateGroup5, recordSpk)));
}

void pushMergedNeuronUpdate6recordSpkToDevice(unsigned int idx, uint32_t* value) {
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronUpdateGroup6, &value, sizeof(value), (sizeof(MergedNeuronUpdateGroup6) * (idx)) + offsetof(MergedNeuronUpdateGroup6, recordSpk)));
}

void pushMergedNeuronUpdate7recordSpkToDevice(unsigned int idx, uint32_t* value) {
    CHECK_CUDA_ERRORS(cudaMemcpyToSymbolAsync(d_mergedNeuronUpdateGroup7, &value, sizeof(value), (sizeof(MergedNeuronUpdateGroup7) * (idx)) + offsetof(MergedNeuronUpdateGroup7, recordSpk)));
}

__device__ __constant__ unsigned int d_mergedNeuronUpdateGroupStartID0[] = {0, 1664, 3392, };
__device__ __constant__ unsigned int d_mergedNeuronUpdateGroupStartID1[] = {3712, };
__device__ __constant__ unsigned int d_mergedNeuronUpdateGroupStartID2[] = {5504, };
__device__ __constant__ unsigned int d_mergedNeuronUpdateGroupStartID3[] = {21056, 23680, };
__device__ __constant__ unsigned int d_mergedNeuronUpdateGroupStartID4[] = {25600, 45888, };
__device__ __constant__ unsigned int d_mergedNeuronUpdateGroupStartID5[] = {50432, };
__device__ __constant__ unsigned int d_mergedNeuronUpdateGroupStartID6[] = {72064, };
__device__ __constant__ unsigned int d_mergedNeuronUpdateGroupStartID7[] = {147008, 198784, 205824, 209920, 211520, 213504, };

extern "C" __global__ void neuronSpikeQueueUpdateKernel() {
    const unsigned int id = 32 * blockIdx.x + threadIdx.x;
    if(id < 17) {
        struct MergedNeuronSpikeQueueUpdateGroup0 *group = &d_mergedNeuronSpikeQueueUpdateGroup0[id - 0]; 
        group->spkCnt[0] = 0;
    }
}

extern "C" __global__ void updateNeuronsKernel(float t, unsigned int recordingTimestep)
 {
    const unsigned int id = 64 * blockIdx.x + threadIdx.x; 
    __shared__ unsigned int shSpk[64];
    __shared__ unsigned int shPosSpk;
    __shared__ unsigned int shSpkCount;
    if (threadIdx.x == 0) {
        shSpkCount = 0;
    }
    
    __shared__ uint32_t shSpkRecord[2];
    if (threadIdx.x < 2) {
        shSpkRecord[threadIdx.x] = 0;
    }
    __syncthreads();
    // merged0
    if(id < 3712) {
        unsigned int lo = 0;
        unsigned int hi = 3;
        while(lo < hi)
         {
            const unsigned int mid = (lo + hi) / 2;
            if(id < d_mergedNeuronUpdateGroupStartID0[mid]) {
                hi = mid;
            }
            else {
                lo = mid + 1;
            }
        }
        struct MergedNeuronUpdateGroup0 *group = &d_mergedNeuronUpdateGroup0[lo - 1]; 
        const unsigned int groupStartID = d_mergedNeuronUpdateGroupStartID0[lo - 1];
        const unsigned int lid = id - groupStartID;
        
        if(lid < group->numNeurons) {
            scalar lV = group->V[lid];
            scalar lRefracTime = group->RefracTime[lid];
            
            float Isyn = 0;
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn0[lid];
                float *denDelayFront = &group->denDelayInSyn0[(*group->denDelayPtrInSyn0 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn0[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn1[lid];
                float *denDelayFront = &group->denDelayInSyn1[(*group->denDelayPtrInSyn1 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn1[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn2[lid];
                float *denDelayFront = &group->denDelayInSyn2[(*group->denDelayPtrInSyn2 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn2[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn3[lid];
                float *denDelayFront = &group->denDelayInSyn3[(*group->denDelayPtrInSyn3 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn3[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn4[lid];
                float *denDelayFront = &group->denDelayInSyn4[(*group->denDelayPtrInSyn4 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn4[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn5[lid];
                float *denDelayFront = &group->denDelayInSyn5[(*group->denDelayPtrInSyn5 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn5[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn6[lid];
                float *denDelayFront = &group->denDelayInSyn6[(*group->denDelayPtrInSyn6 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn6[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn7[lid];
                float *denDelayFront = &group->denDelayInSyn7[(*group->denDelayPtrInSyn7 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn7[lid] = linSyn;
            }
            // test whether spike condition was fulfilled previously
            // calculate membrane potential
            if (lRefracTime <= 0.0f) {
              scalar alpha = ((Isyn + (5.00999987125396729e-01f)) * group->Rmembrane) + group->Vrest;
              lV = alpha - (group->ExpTC * (alpha - lV));
            }
            else {
              lRefracTime -= DT;
            }
            
            // test for and register a true spike
            if (lRefracTime <= 0.0f && lV >= (-5.00000000000000000e+01f)) {
                const unsigned int spkIdx = atomicAdd(&shSpkCount, 1);
                shSpk[spkIdx] = lid;
                atomicOr(&shSpkRecord[threadIdx.x / 32], 1 << (threadIdx.x % 32));
                // spike reset code
                lV = group->Vreset;
                lRefracTime = (1.00000000000000000e+00f);
                
            }
            group->V[lid] = lV;
            group->RefracTime[lid] = lRefracTime;
        }
        __syncthreads();
        if(threadIdx.x == 0) {
            if (shSpkCount > 0) {
                shPosSpk = atomicAdd(&group->spkCnt[0], shSpkCount);
            }
        }
        __syncthreads();
        if(threadIdx.x < shSpkCount) {
            const unsigned int n = shSpk[threadIdx.x];
            group->spk[shPosSpk + threadIdx.x] = n;
        }
        if(threadIdx.x < 2) {
            const unsigned int numRecordingWords = (group->numNeurons + 31) / 32;
            const unsigned int popWordIdx = (lid / 32) + threadIdx.x;
            if(popWordIdx < numRecordingWords) {
                group->recordSpk[(recordingTimestep * numRecordingWords * 1) + popWordIdx] = shSpkRecord[threadIdx.x];
            }
        }
    }
    // merged1
    if(id >= 3712 && id < 5504) {
        struct MergedNeuronUpdateGroup1 *group = &d_mergedNeuronUpdateGroup1[0]; 
        const unsigned int lid = id - 3712;
        
        if(lid < group->numNeurons) {
            scalar lV = group->V[lid];
            scalar lRefracTime = group->RefracTime[lid];
            
            float Isyn = 0;
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn0[lid];
                float *denDelayFront = &group->denDelayInSyn0[(*group->denDelayPtrInSyn0 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn0[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn1[lid];
                float *denDelayFront = &group->denDelayInSyn1[(*group->denDelayPtrInSyn1 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn1[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn2[lid];
                float *denDelayFront = &group->denDelayInSyn2[(*group->denDelayPtrInSyn2 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn2[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn3[lid];
                float *denDelayFront = &group->denDelayInSyn3[(*group->denDelayPtrInSyn3 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn3[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn4[lid];
                float *denDelayFront = &group->denDelayInSyn4[(*group->denDelayPtrInSyn4 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn4[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn5[lid];
                float *denDelayFront = &group->denDelayInSyn5[(*group->denDelayPtrInSyn5 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn5[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn6[lid];
                float *denDelayFront = &group->denDelayInSyn6[(*group->denDelayPtrInSyn6 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn6[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn7[lid];
                float *denDelayFront = &group->denDelayInSyn7[(*group->denDelayPtrInSyn7 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn7[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn8[lid];
                float *denDelayFront = &group->denDelayInSyn8[(*group->denDelayPtrInSyn8 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn8[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn9[lid];
                float *denDelayFront = &group->denDelayInSyn9[(*group->denDelayPtrInSyn9 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn9[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn10[lid];
                float *denDelayFront = &group->denDelayInSyn10[(*group->denDelayPtrInSyn10 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn10[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn11[lid];
                float *denDelayFront = &group->denDelayInSyn11[(*group->denDelayPtrInSyn11 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn11[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn12[lid];
                float *denDelayFront = &group->denDelayInSyn12[(*group->denDelayPtrInSyn12 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn12[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn13[lid];
                float *denDelayFront = &group->denDelayInSyn13[(*group->denDelayPtrInSyn13 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn13[lid] = linSyn;
            }
            // test whether spike condition was fulfilled previously
            // calculate membrane potential
            if (lRefracTime <= 0.0f) {
              scalar alpha = ((Isyn + (4.81000006198883057e-01f)) * (5.00000000000000000e+01f)) + (-8.60000000000000000e+01f);
              lV = alpha - ((9.90049833749168107e-01f) * (alpha - lV));
            }
            else {
              lRefracTime -= DT;
            }
            
            // test for and register a true spike
            if (lRefracTime <= 0.0f && lV >= (-5.00000000000000000e+01f)) {
                const unsigned int spkIdx = atomicAdd(&shSpkCount, 1);
                shSpk[spkIdx] = lid;
                atomicOr(&shSpkRecord[threadIdx.x / 32], 1 << (threadIdx.x % 32));
                // spike reset code
                lV = (-6.00000000000000000e+01f);
                lRefracTime = (1.00000000000000000e+00f);
                
            }
            group->V[lid] = lV;
            group->RefracTime[lid] = lRefracTime;
        }
        __syncthreads();
        if(threadIdx.x == 0) {
            if (shSpkCount > 0) {
                shPosSpk = atomicAdd(&group->spkCnt[0], shSpkCount);
            }
        }
        __syncthreads();
        if(threadIdx.x < shSpkCount) {
            const unsigned int n = shSpk[threadIdx.x];
            group->spk[shPosSpk + threadIdx.x] = n;
        }
        if(threadIdx.x < 2) {
            const unsigned int numRecordingWords = (group->numNeurons + 31) / 32;
            const unsigned int popWordIdx = (lid / 32) + threadIdx.x;
            if(popWordIdx < numRecordingWords) {
                group->recordSpk[(recordingTimestep * numRecordingWords * 1) + popWordIdx] = shSpkRecord[threadIdx.x];
            }
        }
    }
    // merged2
    if(id >= 5504 && id < 21056) {
        struct MergedNeuronUpdateGroup2 *group = &d_mergedNeuronUpdateGroup2[0]; 
        const unsigned int lid = id - 5504;
        
        if(lid < group->numNeurons) {
            scalar lV = group->V[lid];
            scalar lRefracTime = group->RefracTime[lid];
            
            float Isyn = 0;
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn0[lid];
                float *denDelayFront = &group->denDelayInSyn0[(*group->denDelayPtrInSyn0 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn0[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn1[lid];
                float *denDelayFront = &group->denDelayInSyn1[(*group->denDelayPtrInSyn1 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn1[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn2[lid];
                float *denDelayFront = &group->denDelayInSyn2[(*group->denDelayPtrInSyn2 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn2[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn3[lid];
                float *denDelayFront = &group->denDelayInSyn3[(*group->denDelayPtrInSyn3 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn3[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn4[lid];
                float *denDelayFront = &group->denDelayInSyn4[(*group->denDelayPtrInSyn4 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn4[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn5[lid];
                float *denDelayFront = &group->denDelayInSyn5[(*group->denDelayPtrInSyn5 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn5[lid] = linSyn;
            }
            // test whether spike condition was fulfilled previously
            // calculate membrane potential
            if (lRefracTime <= 0.0f) {
              scalar alpha = ((Isyn + (5.50999999046325684e-01f)) * (2.00000000000000000e+02f)) + (-7.00000000000000000e+01f);
              lV = alpha - ((9.95012479192682320e-01f) * (alpha - lV));
            }
            else {
              lRefracTime -= DT;
            }
            
            // test for and register a true spike
            if (lRefracTime <= 0.0f && lV >= (-5.00000000000000000e+01f)) {
                const unsigned int spkIdx = atomicAdd(&shSpkCount, 1);
                shSpk[spkIdx] = lid;
                atomicOr(&shSpkRecord[threadIdx.x / 32], 1 << (threadIdx.x % 32));
                // spike reset code
                lV = (-6.50000000000000000e+01f);
                lRefracTime = (1.00000000000000000e+00f);
                
            }
            group->V[lid] = lV;
            group->RefracTime[lid] = lRefracTime;
        }
        __syncthreads();
        if(threadIdx.x == 0) {
            if (shSpkCount > 0) {
                shPosSpk = atomicAdd(&group->spkCnt[0], shSpkCount);
            }
        }
        __syncthreads();
        if(threadIdx.x < shSpkCount) {
            const unsigned int n = shSpk[threadIdx.x];
            group->spk[shPosSpk + threadIdx.x] = n;
        }
        if(threadIdx.x < 2) {
            const unsigned int numRecordingWords = (group->numNeurons + 31) / 32;
            const unsigned int popWordIdx = (lid / 32) + threadIdx.x;
            if(popWordIdx < numRecordingWords) {
                group->recordSpk[(recordingTimestep * numRecordingWords * 1) + popWordIdx] = shSpkRecord[threadIdx.x];
            }
        }
    }
    // merged3
    if(id >= 21056 && id < 25600) {
        unsigned int lo = 0;
        unsigned int hi = 2;
        while(lo < hi)
         {
            const unsigned int mid = (lo + hi) / 2;
            if(id < d_mergedNeuronUpdateGroupStartID3[mid]) {
                hi = mid;
            }
            else {
                lo = mid + 1;
            }
        }
        struct MergedNeuronUpdateGroup3 *group = &d_mergedNeuronUpdateGroup3[lo - 1]; 
        const unsigned int groupStartID = d_mergedNeuronUpdateGroupStartID3[lo - 1];
        const unsigned int lid = id - groupStartID;
        
        if(lid < group->numNeurons) {
            scalar lV = group->V[lid];
            scalar lRefracTime = group->RefracTime[lid];
            
            float Isyn = 0;
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn0[lid];
                float *denDelayFront = &group->denDelayInSyn0[(*group->denDelayPtrInSyn0 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn0[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn1[lid];
                float *denDelayFront = &group->denDelayInSyn1[(*group->denDelayPtrInSyn1 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn1[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn2[lid];
                float *denDelayFront = &group->denDelayInSyn2[(*group->denDelayPtrInSyn2 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn2[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn3[lid];
                float *denDelayFront = &group->denDelayInSyn3[(*group->denDelayPtrInSyn3 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn3[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn4[lid];
                float *denDelayFront = &group->denDelayInSyn4[(*group->denDelayPtrInSyn4 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn4[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn5[lid];
                float *denDelayFront = &group->denDelayInSyn5[(*group->denDelayPtrInSyn5 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn5[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn6[lid];
                float *denDelayFront = &group->denDelayInSyn6[(*group->denDelayPtrInSyn6 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn6[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn7[lid];
                float *denDelayFront = &group->denDelayInSyn7[(*group->denDelayPtrInSyn7 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn7[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn8[lid];
                float *denDelayFront = &group->denDelayInSyn8[(*group->denDelayPtrInSyn8 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn8[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn9[lid];
                float *denDelayFront = &group->denDelayInSyn9[(*group->denDelayPtrInSyn9 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn9[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn10[lid];
                float *denDelayFront = &group->denDelayInSyn10[(*group->denDelayPtrInSyn10 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn10[lid] = linSyn;
            }
            // test whether spike condition was fulfilled previously
            // calculate membrane potential
            if (lRefracTime <= 0.0f) {
              scalar alpha = ((Isyn + group->Ioffset) * group->Rmembrane) + group->Vrest;
              lV = alpha - (group->ExpTC * (alpha - lV));
            }
            else {
              lRefracTime -= DT;
            }
            
            // test for and register a true spike
            if (lRefracTime <= 0.0f && lV >= (-5.00000000000000000e+01f)) {
                const unsigned int spkIdx = atomicAdd(&shSpkCount, 1);
                shSpk[spkIdx] = lid;
                atomicOr(&shSpkRecord[threadIdx.x / 32], 1 << (threadIdx.x % 32));
                // spike reset code
                lV = (-6.00000000000000000e+01f);
                lRefracTime = (1.00000000000000000e+00f);
                
            }
            group->V[lid] = lV;
            group->RefracTime[lid] = lRefracTime;
        }
        __syncthreads();
        if(threadIdx.x == 0) {
            if (shSpkCount > 0) {
                shPosSpk = atomicAdd(&group->spkCnt[0], shSpkCount);
            }
        }
        __syncthreads();
        if(threadIdx.x < shSpkCount) {
            const unsigned int n = shSpk[threadIdx.x];
            group->spk[shPosSpk + threadIdx.x] = n;
        }
        if(threadIdx.x < 2) {
            const unsigned int numRecordingWords = (group->numNeurons + 31) / 32;
            const unsigned int popWordIdx = (lid / 32) + threadIdx.x;
            if(popWordIdx < numRecordingWords) {
                group->recordSpk[(recordingTimestep * numRecordingWords * 1) + popWordIdx] = shSpkRecord[threadIdx.x];
            }
        }
    }
    // merged4
    if(id >= 25600 && id < 50432) {
        unsigned int lo = 0;
        unsigned int hi = 2;
        while(lo < hi)
         {
            const unsigned int mid = (lo + hi) / 2;
            if(id < d_mergedNeuronUpdateGroupStartID4[mid]) {
                hi = mid;
            }
            else {
                lo = mid + 1;
            }
        }
        struct MergedNeuronUpdateGroup4 *group = &d_mergedNeuronUpdateGroup4[lo - 1]; 
        const unsigned int groupStartID = d_mergedNeuronUpdateGroupStartID4[lo - 1];
        const unsigned int lid = id - groupStartID;
        
        if(lid < group->numNeurons) {
            scalar lV = group->V[lid];
            scalar lRefracTime = group->RefracTime[lid];
            
            float Isyn = 0;
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn0[lid];
                float *denDelayFront = &group->denDelayInSyn0[(*group->denDelayPtrInSyn0 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn0[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn1[lid];
                float *denDelayFront = &group->denDelayInSyn1[(*group->denDelayPtrInSyn1 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn1[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn2[lid];
                float *denDelayFront = &group->denDelayInSyn2[(*group->denDelayPtrInSyn2 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn2[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn3[lid];
                float *denDelayFront = &group->denDelayInSyn3[(*group->denDelayPtrInSyn3 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn3[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn4[lid];
                float *denDelayFront = &group->denDelayInSyn4[(*group->denDelayPtrInSyn4 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn4[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn5[lid];
                float *denDelayFront = &group->denDelayInSyn5[(*group->denDelayPtrInSyn5 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn5[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn6[lid];
                float *denDelayFront = &group->denDelayInSyn6[(*group->denDelayPtrInSyn6 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn6[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn7[lid];
                float *denDelayFront = &group->denDelayInSyn7[(*group->denDelayPtrInSyn7 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn7[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn8[lid];
                float *denDelayFront = &group->denDelayInSyn8[(*group->denDelayPtrInSyn8 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn8[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn9[lid];
                float *denDelayFront = &group->denDelayInSyn9[(*group->denDelayPtrInSyn9 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn9[lid] = linSyn;
            }
            // test whether spike condition was fulfilled previously
            // calculate membrane potential
            if (lRefracTime <= 0.0f) {
              scalar alpha = ((Isyn + group->Ioffset) * group->Rmembrane) + (-7.00000000000000000e+01f);
              lV = alpha - ((9.95012479192682320e-01f) * (alpha - lV));
            }
            else {
              lRefracTime -= DT;
            }
            
            // test for and register a true spike
            if (lRefracTime <= 0.0f && lV >= (-5.00000000000000000e+01f)) {
                const unsigned int spkIdx = atomicAdd(&shSpkCount, 1);
                shSpk[spkIdx] = lid;
                atomicOr(&shSpkRecord[threadIdx.x / 32], 1 << (threadIdx.x % 32));
                // spike reset code
                lV = group->Vreset;
                lRefracTime = group->TauRefrac;
                
            }
            group->V[lid] = lV;
            group->RefracTime[lid] = lRefracTime;
        }
        __syncthreads();
        if(threadIdx.x == 0) {
            if (shSpkCount > 0) {
                shPosSpk = atomicAdd(&group->spkCnt[0], shSpkCount);
            }
        }
        __syncthreads();
        if(threadIdx.x < shSpkCount) {
            const unsigned int n = shSpk[threadIdx.x];
            group->spk[shPosSpk + threadIdx.x] = n;
        }
        if(threadIdx.x < 2) {
            const unsigned int numRecordingWords = (group->numNeurons + 31) / 32;
            const unsigned int popWordIdx = (lid / 32) + threadIdx.x;
            if(popWordIdx < numRecordingWords) {
                group->recordSpk[(recordingTimestep * numRecordingWords * 1) + popWordIdx] = shSpkRecord[threadIdx.x];
            }
        }
    }
    // merged5
    if(id >= 50432 && id < 72064) {
        struct MergedNeuronUpdateGroup5 *group = &d_mergedNeuronUpdateGroup5[0]; 
        const unsigned int lid = id - 50432;
        
        if(lid < group->numNeurons) {
            scalar lV = group->V[lid];
            scalar lRefracTime = group->RefracTime[lid];
            
            float Isyn = 0;
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn0[lid];
                float *denDelayFront = &group->denDelayInSyn0[(*group->denDelayPtrInSyn0 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn0[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn1[lid];
                float *denDelayFront = &group->denDelayInSyn1[(*group->denDelayPtrInSyn1 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn1[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn2[lid];
                float *denDelayFront = &group->denDelayInSyn2[(*group->denDelayPtrInSyn2 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn2[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn3[lid];
                float *denDelayFront = &group->denDelayInSyn3[(*group->denDelayPtrInSyn3 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn3[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn4[lid];
                float *denDelayFront = &group->denDelayInSyn4[(*group->denDelayPtrInSyn4 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn4[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn5[lid];
                float *denDelayFront = &group->denDelayInSyn5[(*group->denDelayPtrInSyn5 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn5[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn6[lid];
                float *denDelayFront = &group->denDelayInSyn6[(*group->denDelayPtrInSyn6 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn6[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn7[lid];
                float *denDelayFront = &group->denDelayInSyn7[(*group->denDelayPtrInSyn7 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn7[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn8[lid];
                float *denDelayFront = &group->denDelayInSyn8[(*group->denDelayPtrInSyn8 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn8[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn9[lid];
                float *denDelayFront = &group->denDelayInSyn9[(*group->denDelayPtrInSyn9 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn9[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn10[lid];
                float *denDelayFront = &group->denDelayInSyn10[(*group->denDelayPtrInSyn10 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn10[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn11[lid];
                float *denDelayFront = &group->denDelayInSyn11[(*group->denDelayPtrInSyn11 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn11[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn12[lid];
                float *denDelayFront = &group->denDelayInSyn12[(*group->denDelayPtrInSyn12 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn12[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn13[lid];
                float *denDelayFront = &group->denDelayInSyn13[(*group->denDelayPtrInSyn13 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn13[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn14[lid];
                float *denDelayFront = &group->denDelayInSyn14[(*group->denDelayPtrInSyn14 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn14[lid] = linSyn;
            }
            // test whether spike condition was fulfilled previously
            // calculate membrane potential
            if (lRefracTime <= 0.0f) {
              scalar alpha = ((Isyn + (5.50999999046325684e-01f)) * (4.00000000000000000e+01f)) + (-7.00000000000000000e+01f);
              lV = alpha - ((9.95012479192682320e-01f) * (alpha - lV));
            }
            else {
              lRefracTime -= DT;
            }
            
            // test for and register a true spike
            if (lRefracTime <= 0.0f && lV >= (-5.00000000000000000e+01f)) {
                const unsigned int spkIdx = atomicAdd(&shSpkCount, 1);
                shSpk[spkIdx] = lid;
                atomicOr(&shSpkRecord[threadIdx.x / 32], 1 << (threadIdx.x % 32));
                // spike reset code
                lV = (-6.00000000000000000e+01f);
                lRefracTime = (2.00000000000000000e+00f);
                
            }
            group->V[lid] = lV;
            group->RefracTime[lid] = lRefracTime;
        }
        __syncthreads();
        if(threadIdx.x == 0) {
            if (shSpkCount > 0) {
                shPosSpk = atomicAdd(&group->spkCnt[0], shSpkCount);
            }
        }
        __syncthreads();
        if(threadIdx.x < shSpkCount) {
            const unsigned int n = shSpk[threadIdx.x];
            group->spk[shPosSpk + threadIdx.x] = n;
        }
        if(threadIdx.x < 2) {
            const unsigned int numRecordingWords = (group->numNeurons + 31) / 32;
            const unsigned int popWordIdx = (lid / 32) + threadIdx.x;
            if(popWordIdx < numRecordingWords) {
                group->recordSpk[(recordingTimestep * numRecordingWords * 1) + popWordIdx] = shSpkRecord[threadIdx.x];
            }
        }
    }
    // merged6
    if(id >= 72064 && id < 147008) {
        struct MergedNeuronUpdateGroup6 *group = &d_mergedNeuronUpdateGroup6[0]; 
        const unsigned int lid = id - 72064;
        
        if(lid < group->numNeurons) {
            scalar lV = group->V[lid];
            scalar lRefracTime = group->RefracTime[lid];
            
            float Isyn = 0;
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn0[lid];
                float *denDelayFront = &group->denDelayInSyn0[(*group->denDelayPtrInSyn0 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn0[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn1[lid];
                float *denDelayFront = &group->denDelayInSyn1[(*group->denDelayPtrInSyn1 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn1[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn2[lid];
                float *denDelayFront = &group->denDelayInSyn2[(*group->denDelayPtrInSyn2 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn2[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn3[lid];
                float *denDelayFront = &group->denDelayInSyn3[(*group->denDelayPtrInSyn3 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn3[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn4[lid];
                float *denDelayFront = &group->denDelayInSyn4[(*group->denDelayPtrInSyn4 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn4[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn5[lid];
                float *denDelayFront = &group->denDelayInSyn5[(*group->denDelayPtrInSyn5 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn5[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn6[lid];
                float *denDelayFront = &group->denDelayInSyn6[(*group->denDelayPtrInSyn6 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn6[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn7[lid];
                float *denDelayFront = &group->denDelayInSyn7[(*group->denDelayPtrInSyn7 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn7[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn8[lid];
                float *denDelayFront = &group->denDelayInSyn8[(*group->denDelayPtrInSyn8 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn8[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn9[lid];
                float *denDelayFront = &group->denDelayInSyn9[(*group->denDelayPtrInSyn9 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn9[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn10[lid];
                float *denDelayFront = &group->denDelayInSyn10[(*group->denDelayPtrInSyn10 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn10[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn11[lid];
                float *denDelayFront = &group->denDelayInSyn11[(*group->denDelayPtrInSyn11 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn11[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn12[lid];
                float *denDelayFront = &group->denDelayInSyn12[(*group->denDelayPtrInSyn12 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn12[lid] = linSyn;
            }
            // test whether spike condition was fulfilled previously
            // calculate membrane potential
            if (lRefracTime <= 0.0f) {
              scalar alpha = ((Isyn + (6.01000010967254639e-01f)) * (4.00000000000000000e+01f)) + (-7.00000000000000000e+01f);
              lV = alpha - ((9.95012479192682320e-01f) * (alpha - lV));
            }
            else {
              lRefracTime -= DT;
            }
            
            // test for and register a true spike
            if (lRefracTime <= 0.0f && lV >= (-5.00000000000000000e+01f)) {
                const unsigned int spkIdx = atomicAdd(&shSpkCount, 1);
                shSpk[spkIdx] = lid;
                atomicOr(&shSpkRecord[threadIdx.x / 32], 1 << (threadIdx.x % 32));
                // spike reset code
                lV = (-6.00000000000000000e+01f);
                lRefracTime = (2.00000000000000000e+00f);
                
            }
            group->V[lid] = lV;
            group->RefracTime[lid] = lRefracTime;
        }
        __syncthreads();
        if(threadIdx.x == 0) {
            if (shSpkCount > 0) {
                shPosSpk = atomicAdd(&group->spkCnt[0], shSpkCount);
            }
        }
        __syncthreads();
        if(threadIdx.x < shSpkCount) {
            const unsigned int n = shSpk[threadIdx.x];
            group->spk[shPosSpk + threadIdx.x] = n;
        }
        if(threadIdx.x < 2) {
            const unsigned int numRecordingWords = (group->numNeurons + 31) / 32;
            const unsigned int popWordIdx = (lid / 32) + threadIdx.x;
            if(popWordIdx < numRecordingWords) {
                group->recordSpk[(recordingTimestep * numRecordingWords * 1) + popWordIdx] = shSpkRecord[threadIdx.x];
            }
        }
    }
    // merged7
    if(id >= 147008 && id < 213888) {
        unsigned int lo = 0;
        unsigned int hi = 6;
        while(lo < hi)
         {
            const unsigned int mid = (lo + hi) / 2;
            if(id < d_mergedNeuronUpdateGroupStartID7[mid]) {
                hi = mid;
            }
            else {
                lo = mid + 1;
            }
        }
        struct MergedNeuronUpdateGroup7 *group = &d_mergedNeuronUpdateGroup7[lo - 1]; 
        const unsigned int groupStartID = d_mergedNeuronUpdateGroupStartID7[lo - 1];
        const unsigned int lid = id - groupStartID;
        
        if(lid < group->numNeurons) {
            scalar lV = group->V[lid];
            scalar lRefracTime = group->RefracTime[lid];
            
            float Isyn = 0;
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn0[lid];
                float *denDelayFront = &group->denDelayInSyn0[(*group->denDelayPtrInSyn0 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn0[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn1[lid];
                float *denDelayFront = &group->denDelayInSyn1[(*group->denDelayPtrInSyn1 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn1[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn2[lid];
                float *denDelayFront = &group->denDelayInSyn2[(*group->denDelayPtrInSyn2 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn2[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn3[lid];
                float *denDelayFront = &group->denDelayInSyn3[(*group->denDelayPtrInSyn3 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn3[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn4[lid];
                float *denDelayFront = &group->denDelayInSyn4[(*group->denDelayPtrInSyn4 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn4[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn5[lid];
                float *denDelayFront = &group->denDelayInSyn5[(*group->denDelayPtrInSyn5 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn5[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn6[lid];
                float *denDelayFront = &group->denDelayInSyn6[(*group->denDelayPtrInSyn6 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn6[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn7[lid];
                float *denDelayFront = &group->denDelayInSyn7[(*group->denDelayPtrInSyn7 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn7[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn8[lid];
                float *denDelayFront = &group->denDelayInSyn8[(*group->denDelayPtrInSyn8 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn8[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn9[lid];
                float *denDelayFront = &group->denDelayInSyn9[(*group->denDelayPtrInSyn9 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn9[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn10[lid];
                float *denDelayFront = &group->denDelayInSyn10[(*group->denDelayPtrInSyn10 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn10[lid] = linSyn;
            }
             {
                // pull inSyn values in a coalesced access
                float linSyn = group->inSynInSyn11[lid];
                float *denDelayFront = &group->denDelayInSyn11[(*group->denDelayPtrInSyn11 * group->numNeurons) + lid];
                linSyn += *denDelayFront;
                *denDelayFront = 0.000000000e+00f;
                Isyn += (9.06346234610090895e-01f) * linSyn;
                linSyn *= (8.18730753077981821e-01f);
                group->inSynInSyn11[lid] = linSyn;
            }
            // test whether spike condition was fulfilled previously
            // calculate membrane potential
            if (lRefracTime <= 0.0f) {
              scalar alpha = ((Isyn + group->Ioffset) * group->Rmembrane) + group->Vrest;
              lV = alpha - (group->ExpTC * (alpha - lV));
            }
            else {
              lRefracTime -= DT;
            }
            
            // test for and register a true spike
            if (lRefracTime <= 0.0f && lV >= (-5.00000000000000000e+01f)) {
                const unsigned int spkIdx = atomicAdd(&shSpkCount, 1);
                shSpk[spkIdx] = lid;
                atomicOr(&shSpkRecord[threadIdx.x / 32], 1 << (threadIdx.x % 32));
                // spike reset code
                lV = group->Vreset;
                lRefracTime = group->TauRefrac;
                
            }
            group->V[lid] = lV;
            group->RefracTime[lid] = lRefracTime;
        }
        __syncthreads();
        if(threadIdx.x == 0) {
            if (shSpkCount > 0) {
                shPosSpk = atomicAdd(&group->spkCnt[0], shSpkCount);
            }
        }
        __syncthreads();
        if(threadIdx.x < shSpkCount) {
            const unsigned int n = shSpk[threadIdx.x];
            group->spk[shPosSpk + threadIdx.x] = n;
        }
        if(threadIdx.x < 2) {
            const unsigned int numRecordingWords = (group->numNeurons + 31) / 32;
            const unsigned int popWordIdx = (lid / 32) + threadIdx.x;
            if(popWordIdx < numRecordingWords) {
                group->recordSpk[(recordingTimestep * numRecordingWords * 1) + popWordIdx] = shSpkRecord[threadIdx.x];
            }
        }
    }
}
void updateNeurons(float t, unsigned int recordingTimestep) {
     {
        const dim3 threads(32, 1);
        const dim3 grid(1, 1);
        neuronSpikeQueueUpdateKernel<<<grid, threads>>>();
        CHECK_CUDA_ERRORS(cudaPeekAtLastError());
    }
     {
        const dim3 threads(64, 1);
        const dim3 grid(3342, 1);
        updateNeuronsKernel<<<grid, threads>>>(t, recordingTimestep);
        CHECK_CUDA_ERRORS(cudaPeekAtLastError());
    }
}
